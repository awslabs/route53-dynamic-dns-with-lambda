AWSTemplateFormatVersion: '2010-09-09'
Description: Serverless dynamic DNS & device discovery service for ipv4 & ipv6
## Resource names are keyed off the Stack name.

Parameters:
  route53ZoneName:
    Type: String
    Default: 'greathou.se'
    Description: "Required: Route53 Zone, either existing or name to be created. -- Must not end in '.' -- If it's an existing zone, it must match the zone id passed in route53ZoneId."
    #AllowedPattern: ^([a-zA-Z0-9-].)+[a-zA-Z0-9-]$  #commented out to support unicode
    
  route53ZoneId:
    Type: String
    Default: ''
    Description: Populate to use existing zone.  ie 'Z1FXLQ1OABKR4O' Must be from the same account. --  If omitted, a new zone will be created.  -- If supplied, the ddns system will get IAM permissions to modify existing zone entries.

  defaultTtl:
    Type: String
    Default: 60
    Description: Default DNS record TTL, can be overridden for individual records in DynamoDB config.
    
  apiCname:
    Type: String
    Default: 'ddns'
    Description: "API Endpoint Custom Alias.  Required for enableCloudFront:withCustomAlias"
    #AllowedPattern: ^[a-zA-Z0-9]*$ #commented out to support unicode
    
  enableCloudFront:
    Default: false
    Type: String
    AllowedValues: [false, withCustomAlias, withoutCustomAlias]
    Description: "CloudFront is required for ipv6 or to use a custom dns endpoint (Alias) for your API."

  cloudFrontPriceClass:
    Default: US-Canada-Europe
    Type: String
    AllowedValues: [US-Canada-Europe, US-Canada-Europe-Asia, All-Edge-Locations]
    Description: "Affects price, change propagation times, latency to clients.  See: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html"
        
  acmCertificateARN:
    Default: ''
    Type: String
    Description: "Populate to use ACM Certificate.  Required to use a custom dns endpoint (Alias) for your API. Full ARN of an ACM SSL Certificate in us-east-1 Region.  -- i.e. arn:aws:acm:us-east-1:123456789012:certificate/a1aaab22-11ab-ab12-cd34-12345abc0ab0"

  ddbRcu:
    Default: '3'
    Type: String
    Description: DynamoDB Table Read Capacity Unit - leave at default unless you deploy at significant scale
    
  ddbWcu:
    Default: '3'
    Type: String
    Description: DynamoDB Table Write Capacity Unit - leave at default unless you deploy at significant scale

  ddbGsiRcu:
    Default: '3'
    Type: String
    Description: DynamoDB Global Secondary Index Read Capacity Unit - leave at default unless you deploy at significant scale
    
  ddbGsiWcu:
    Default: '3'
    Type: String
    Description: DynamoDB Global Secondary Index Write Capacity Unit - leave at default unless you deploy at significant scale
                
  templateVersion:
    Type: String
    Default: 1
    Description: "For debugging, increment this parameter to force CFN to re-run the template"
    ## Uses a matching output to force the update

Metadata: 
  AWS::CloudFormation::Interface: 
    ParameterGroups: 
      - 
        Label: 
          default: "DNS Zone:"
        Parameters: 
          - route53ZoneName
          - route53ZoneId
          - defaultTtl
      - 
        Label: 
          default: "CloudFront Configuration:"
        Parameters: 
          - enableCloudFront
          - apiCname
          - acmCertificateARN
          - cloudFrontPriceClass
      -
        Label: 
          default: "DynamoDB Configuration:"
        Parameters: 
          - ddbRcu
          - ddbWcu
          - ddbGsiRcu
          - ddbGsiWcu
                               
Conditions:
    useExistingZone: !Not [!Equals [ !Ref route53ZoneId , '']]
    createNewZone: !Not [Condition: useExistingZone]
    ## Build a CF dist with alias if:
    ## enableCloudFront:withCustomAlias is set 
    ## and apiCname and acmCertificateARN are not empty 
    cloudfrontAlias: !And 
        - !Equals [ !Ref enableCloudFront , 'withCustomAlias']
        - !Not [!Equals [ !Ref apiCname , '']]
        - !Not [!Equals [ !Ref acmCertificateARN , '']]
    cloudfrontNoAlias: !Equals [ !Ref enableCloudFront , 'withoutCustomAlias']
    enableCloudFront: !Or [ Condition: cloudfrontAlias, Condition: cloudfrontNoAlias]

Mappings: 
    cloudFrontPriceClassMapping: 
      US-Canada-Europe: 
        value: "PriceClass_100"
      US-Canada-Europe-Asia: 
        value: "PriceClass_200"
      All-Edge-Locations: 
        value: "PriceClass_All"
        
Resources:
  route53newZone: 
    Type: "AWS::Route53::HostedZone"
    Condition: createNewZone
    Properties: 
      HostedZoneConfig: 
        Comment: !Sub Zone for ${AWS::StackName}
      Name: !Ref route53ZoneName
      HostedZoneTags: 
        - 
          Key: "CreatedBy"
          Value: !Ref AWS::StackName

  ddnsConfigTable: 
    Type: "AWS::DynamoDB::Table"
    Properties: 
      TableName: !Sub ${AWS::StackName}-config
      AttributeDefinitions: 
        - 
          AttributeName: "hostname"
          AttributeType: "S"
        - 
          AttributeName: "record_type"
          AttributeType: "S"
        - 
          AttributeName: "shared_secret"
          AttributeType: "S"
      KeySchema: 
        - 
          AttributeName: "hostname"
          KeyType: "HASH"
        - 
          AttributeName: "record_type"
          KeyType: "RANGE"
      ProvisionedThroughput: 
        ReadCapacityUnits: !Ref ddbRcu
        WriteCapacityUnits: !Ref ddbWcu
      GlobalSecondaryIndexes:
        -
          IndexName: "shared_secret-index"
          KeySchema:
            - 
              AttributeName: "shared_secret"
              KeyType: "HASH"
          Projection:
            NonKeyAttributes:
              - "hostname"
              - "mac_address"
              - "record_type"
              - "read_privilege"
            ProjectionType: "INCLUDE"
          ProvisionedThroughput:
            ReadCapacityUnits: !Ref ddbGsiRcu
            WriteCapacityUnits: !Ref ddbGsiWcu

  ddnsConfigBucket:
    Type: "AWS::S3::Bucket"
    Properties:
      BucketName: !Join [ "-", [ !Ref "AWS::StackName", !Ref "AWS::Region", !Ref "AWS::AccountId"] ]
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
        - Id: Delete_Old_Versions
          NoncurrentVersionExpirationInDays: 90
          Status: Enabled

  lambdaDdnsFunction:
    Type: "AWS::Lambda::Function"
    DependsOn: ddnsSourceToS3
    Properties:
      FunctionName: !Sub ${AWS::StackName}-ddns
      Handler: index.lambda_handler
      Runtime: python2.7
      MemorySize: 512
      Timeout: 30
      Role: !GetAtt lambdaDdnsRole.Arn
      Environment:
        Variables:
          ddns_config_table: !Ref ddnsConfigTable
          route_53_zone_id: !If [useExistingZone, !Ref route53ZoneId, !Ref route53newZone]
          route_53_zone_name: !Ref route53ZoneName
          default_ttl: !Ref defaultTtl
      Code:
        S3Bucket: !Ref ddnsConfigBucket
        S3Key: ddns_lambda.zip
        S3ObjectVersion: !GetAtt ddnsSourceToS3.ddns_lambda-S3ObjectVersion

# Builds s3 zip objects for Lambda source.
  setupLambda:
    Type: AWS::Lambda::Function
    DependsOn: 
        - ddnsConfigTable 
        - lambdaDdnsRole
    Properties:
      FunctionName: !Sub ${AWS::StackName}-setup
      Handler: index.lambda_handler
      Runtime: python2.7
      Timeout: 120
      Role: !GetAtt lambdaDdnsRole.Arn
      Environment:
        Variables:
          ddns_config_table: !Ref ddnsConfigTable
          route_53_zone_id: !If [useExistingZone, !Ref route53ZoneId, !Ref route53newZone]
          route_53_zone_name: !Ref route53ZoneName
          aws_region: !Ref AWS::Region
          api_cname: !If [cloudfrontAlias, !Sub '${apiCname}.${route53ZoneName}', '']
      Code:
        S3Bucket: !Ref ddnsConfigBucket
        S3Key: setup_lambda.zip
        S3ObjectVersion: !GetAtt setupSourceToS3.setup_lambda-S3ObjectVersion

# Invokes setupLambda to populate sample data to DDB
  runSetup:
    Type: Custom::setupLambda
    DependsOn: setupLambda
    Properties:
      ServiceToken: !GetAtt setupLambda.Arn
      Region: !Ref AWS::Region
      stackName: !Ref AWS::StackName
      forceUpdate: !Ref templateVersion
      run_mode: 'first_run'
      cloudfront_url: ''
      
# Invokes setupLambda to create CNAME to CloudFront
# after CloudFront distribution creation
# only used for a CloudFront custom alias deployment    
  runSetupSecondRun:
    Type: Custom::setupLambda
    Condition: cloudfrontAlias
    DependsOn: 
      - setupLambda
      - ddnsCloudFrontAliased
    Properties:
      ServiceToken: !GetAtt setupLambda.Arn
      Region: !Ref AWS::Region
      stackName: !Ref AWS::StackName
      forceUpdate: !Ref templateVersion
      run_mode: 'second_run'
      cloudfront_url: !GetAtt ddnsCloudFrontAliased.DomainName
      
# Builds zip objects in S3 for all Lambda function project code.
# Invoked by
  sourceToS3Lambda:
    Type: AWS::Lambda::Function
    DependsOn: ddnsConfigBucket
    Properties:
      FunctionName: !Sub ${AWS::StackName}-source-to-s3
      Handler: index.lambda_handler
      Runtime: python2.7
      Timeout: 120
      Role: !GetAtt lambdaDdnsRole.Arn
      Code:
        ZipFile: |
          from __future__ import print_function
          import boto3
          import os
          import zipfile
          import httplib
          import uuid
          import urlparse
          import json
           
          print('Loading function')
          from botocore.client import Config
          s3 = boto3.client('s3')
          
          def send_response(request, response, status=None, reason=None):
              """ Send our response to the pre-signed URL supplied by CloudFormation"""
              if status is not None:
                  response['Status'] = status
              if reason is not None:
                  response['Reason'] = reason
              if 'ResponseURL' in request and request['ResponseURL']:
                  url = urlparse.urlparse(request['ResponseURL'])
                  body = json.dumps(response)
                  https = httplib.HTTPSConnection(url.hostname)
                  https.request('PUT', url.path+'?'+url.query, body)
              return response
          
          def lambda_handler(event, context):
              response = {
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Status': 'SUCCESS'
              }
              # PhysicalResourceId is meaningless here, but CloudFormation requires it
              if 'PhysicalResourceId' in event:
                  response['PhysicalResourceId'] = event['PhysicalResourceId']
              else:
                  response['PhysicalResourceId'] = str(uuid.uuid4())
          
              # There is nothing to do for a delete request
              if event['RequestType'] == 'Delete':
                  return send_response(event, response)
              ## Get the S3 Bucket passed in from CFN
              s3TargetBucket=event['ResourceProperties']['s3TargetBucket']
              ## Get the file contents to put in S3 from CFN
              lambda_body=event['ResourceProperties']['lambda_body']
              file_name=event['ResourceProperties']['file_name']
              zip_file = '/tmp/' + file_name + '.zip'
              s3_key = file_name + '.zip'
              ## Write the body variable to a file
              ## and change perms to add exec
              try:
                os.remove('/tmp/index.py') # delete old file in case function is re-used
              except:
                pass
              lambda_file = open('/tmp/index.py', 'w')
              os.chmod('/tmp/index.py', 0777)
              lambda_file.write(lambda_body)
              lambda_file.close()
              ## Build the zip archive
              zip_archive = zipfile.ZipFile(zip_file, 'w')
              zip_archive.write('/tmp/index.py', 'index.py')
              zip_archive.close()
              zip_file = open(zip_file, 'r')
          
              ## Put the archive in S3
              try:
                  s3_response = s3.put_object(
                  Body= zip_file.read(),
                  Bucket= s3TargetBucket,
                  Key= s3_key,
                  )
                  response['Data'] = {
                      's3Success': 'true',
                      file_name + '-S3ObjectVersion': s3_response['VersionId']
                  }
                  response['Reason'] = s3_key + ' added to S3'
                  print(str(s3_response['VersionId']))
              except Exception as E:
                response['Reason'] = 'Event Failed - See CloudWatch logs for the Lamba function backing the custom resource for details'
                ## Un-comment the line below to send a true failure to CFN
                ## will cause a stack rollback on failure and can leave the stack in a state that requires deletion.
                #response['Status'] = 'FAILED'
              # Log it!
              print(str(s3_response))
              print('Response Text: ' + str(response))
              return send_response(event, response)


  ## Invoke the sourceToS3Lambda function and send the body text of files to put in S3
  ## Lambda-backed custom resources provisioned inline in CFN via the Zipfile method have a 4096 byte limit.  
  ## We pass the DDNS Lambda function code to sourceToS3Lambda which zips the code into S3 to avoid exceeding that limit.
  
  setupSourceToS3:
    Type: Custom::sourceToS3Lambda
    DependsOn: sourceToS3Lambda
    Properties:
      ServiceToken: !GetAtt sourceToS3Lambda.Arn
      Region: !Ref "AWS::Region"
      stackName: !Ref AWS::StackName
      s3TargetBucket: !Ref ddnsConfigBucket
      file_name: 'setup_lambda'
      lambda_body: |
            #force function to run by changing this: 0
            from __future__ import print_function
            import boto3
            import datetime  
            import random
            import os   
            import uuid
            import httplib
            import urlparse
            import json
            import time
            
            print('Loading function')
            from botocore.client import Config
            from botocore.exceptions import ClientError
            
            # Import Lambda environment variables
            ddns_config_table = os.environ['ddns_config_table']
            route_53_zone_id = os.environ['route_53_zone_id']
            route_53_zone_name = os.environ['route_53_zone_name']
            aws_region = os.environ['aws_region']
            api_cname = os.environ['api_cname']
            def send_response(request, response, status=None, reason=None):
                """ Send our response to the pre-signed URL supplied by CloudFormation"""
                if status is not None:
                    response['Status'] = status
                if reason is not None:
                    response['Reason'] = reason
                if 'ResponseURL' in request and request['ResponseURL']:
                    url = urlparse.urlparse(request['ResponseURL'])
                    body = json.dumps(response)
                    https = httplib.HTTPSConnection(url.hostname)
                    https.request('PUT', url.path+'?'+url.query, body)
                    # debug
                    print(url.hostname)
                    print('PUT', url.path+'?'+url.query, body)
                print(response)
                return response
            
            def route53_set(aws_region, route_53_zone_id,
                               route_53_record_name, route_53_record_ttl,
                               route_53_record_type, route_53_record_value):
                # Define the Route 53 client
                route53_client = boto3.client(
                    'route53',aws_region
                )
                change_route53_record_set = route53_client.change_resource_record_sets(
                    HostedZoneId=route_53_zone_id,
                    ChangeBatch={
                        'Changes': [
                            {
                                'Action': 'UPSERT',
                                'ResourceRecordSet': {
                                    'Name': route_53_record_name,
                                    'Type': route_53_record_type,
                                    'TTL': route_53_record_ttl,
                                    'ResourceRecords': [
                                        {
                                            'Value': route_53_record_value
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                )
                return change_route53_record_set
               
            def populate_ddb(ddns_config_table, route_53_zone_name):
                try:
                    # Define the DDB client.
                    dynamodb = boto3.resource('dynamodb')
                    dynamodb_table = dynamodb.Table(ddns_config_table)
                    dynamodb_table.put_item(
                      Item={
                      'hostname': 'example-record.' + route_53_zone_name + '.', 
                      'record_type': 'A',
                      'ttl': 60,
                      'shared_secret': ''.join(random.choice('0123456789ABCDEF') for i in range(16)),
                      'lock_record': False, 
                      'read_privilege': False, 
                      'allow_internal': True,
                      'ip_address': '1.1.1.1', 
                      'mac_address': '0A:0A:0A:0A:0A:0A',
                      'last_checked': str(datetime.datetime.now()), 
                      'last_updated': str(datetime.datetime.now()),
                      'last_accessed': '1.2.3.4',
                      'comment': 'example record'
                      }
                    )
                      #'aws_region': aws_region,
                      #'zone_id': route_53_zone_id, 
                    dynamodb_table.put_item(
                      Item={
                      'hostname': 'example-record.' + route_53_zone_name + '.', 
                      'record_type': 'AAAA',
                      'ttl': 60,
                      'shared_secret': ''.join(random.choice('0123456789ABCDEF') for i in range(16)), 
                      'lock_record': False, 
                      'read_privilege': False, 
                      'allow_internal': True,
                      'ip_address': '1:1:1:1:1:1:1:1', 
                      'mac_address': '0A:0A:0A:0A:0A:0A', 
                      'last_checked': str(datetime.datetime.now()), 
                      'last_updated': str(datetime.datetime.now()),
                      'last_accessed': '2:2:2:2:2:2:2:2',
                      'comment': 'example record'
                      }
                    )
                      #'aws_region': aws_region,
                      #'zone_id': route_53_zone_id, 
                    print('Populated sample DDB entries')
                except:
                    print('Failed to populate sample DDB entries')
                  
            ## Main Lambda handler
            def lambda_handler(event, context):
                response = {
                    'StackId': event['StackId'],
                    'RequestId': event['RequestId'],
                    'LogicalResourceId': event['LogicalResourceId'],
                    'Status': 'SUCCESS'
                }
                ## Pass the run mode argument so lambda can tell if this is the first setup run,
                ## Or the second run (post CF creation) that cnames CloudFront
                run_mode=event['ResourceProperties']['run_mode']
                cloudfront_url=event['ResourceProperties']['cloudfront_url']
                # PhysicalResourceId is meaningless here, but CloudFormation requires it
                if 'PhysicalResourceId' in event:
                    response['PhysicalResourceId'] = event['PhysicalResourceId']
                else:
                    response['PhysicalResourceId'] = str(uuid.uuid4())
            
                # There is nothing to do for a delete request
                if event['RequestType'] == 'Delete':
                    return send_response(event, response)
                    
                ## Main function logic    
                try:  
                  print('Run mode: '+run_mode)
                  if run_mode == 'first_run':
                    populate_ddb(ddns_config_table, route_53_zone_name)
                  elif run_mode == 'second_run':
                    print("Setting api CloudFront cname: " + api_cname + " CNAME " + cloudfront_url)
                    route_53_return_dict = route53_set(aws_region, route_53_zone_id, api_cname, 300, 'CNAME', cloudfront_url)
                  response['Reason'] = 'Event Succeeded'
                except ClientError as e:
                  print("Unexpected error: %s" % e)
                  response['Reason'] = 'Event Failed - See CloudWatch logs for the Lamba function backing the custom resource for details'
                  ## Un-comment the line blow to send a true failure to CFN
                  ## will cause a stack rollback on failure and can leave the stack in a state that requires deletion.
                  #response['Status'] = 'FAILED'
                return send_response(event, response)

  ddnsSourceToS3:
    Type: Custom::sourceToS3Lambda
    DependsOn: sourceToS3Lambda
    Properties:
      ServiceToken: !GetAtt sourceToS3Lambda.Arn
      Region: !Ref "AWS::Region"
      stackName: !Ref AWS::StackName
      s3TargetBucket: !Ref ddnsConfigBucket
      file_name: 'ddns_lambda'
      lambda_body: |
        #force function to run by changing this: 0
        # version works with DDB
        # Dynamic DNS via AWS API Gateway, Lambda & Route 53
        # Script variables use lower_case_
        from __future__ import print_function
        import json
        import re
        import hashlib
        import boto3
        import datetime
        import os
        from boto3.dynamodb.conditions import Key, Attr

        # Import Lambda environment variables
        ddns_config_table = os.environ['ddns_config_table']
        route_53_zone_id_imported = os.environ['route_53_zone_id']
        route_53_zone_name_imported = os.environ['route_53_zone_name']
        default_ttl = int(os.environ['default_ttl'])
        aws_region = os.environ['AWS_REGION']

        ''' This function pulls the config entry from DynamoDB 
            It is called by the run_set_mode function.'''
        def ddb_config(route_53_record_name, route_53_record_type, set_ip, source_ip, read_write):
            # Define the DDB client.
            dynamodb = boto3.resource('dynamodb')
            dynamodb_table = dynamodb.Table(ddns_config_table)
            if read_write == 'read':
              try:
                config_record = dynamodb_table.get_item(
                    Key={
                    'hostname': route_53_record_name,
                    'record_type': route_53_record_type
                    })
                dynamodb_table.update_item(
                    Key={
                    'hostname': route_53_record_name,
                    'record_type': route_53_record_type
                    },
                    UpdateExpression='SET last_checked = :now_time , last_accessed = :last_accessed',
                    ConditionExpression='attribute_exists(hostname) AND attribute_exists(record_type)',
                    ExpressionAttributeValues={
                        ':now_time': str(datetime.datetime.now()),
                        ':last_accessed': source_ip
                    }
                )
              except:
                return_status = 'fail'
                return_message = 'ddb_config There was an issue finding '\
                    'or reading the DyanmoDB config item for '+set_hostname+': '+record_type
                return {'return_status': return_status,
                        'return_message': return_message}
              return config_record
            elif read_write == 'write':
                dynamodb_table.update_item(
                    Key={
                    'hostname': route_53_record_name,
                    'record_type': route_53_record_type },
                    UpdateExpression='SET last_updated = :now_time , ip_address = :ip , last_accessed = :last_accessed', 
                    ExpressionAttributeValues={
                        ':now_time': str(datetime.datetime.now()),
                        ':ip': set_ip,
                        ':last_accessed': source_ip
                    },
                    ConditionExpression='attribute_exists(hostname) AND attribute_exists(record_type)'
                )
                return

        ''' This function defines the interaction with Route 53.
            It is called by the run_set_mode function.
            @param execution_mode defines whether to set or get a DNS record
            @param aws_region defines region to call
            @param route_53_zone_id defines the id for the DNS zone
            @param route_53_record_name defines the record, ie www.acme.com.
            @param route_53_record_ttl defines defines the DNS record TTL
            @param route_53_record_type defines record type, should always be 'a'
            @param public_ip defines the current public ip of the client
            '''
        def route53_set(execution_mode, aws_region, route_53_zone_id,
                           route_53_record_name, route_53_record_ttl,
                           route_53_record_type, public_ip):
            # Define the Route 53 client
            route53_client = boto3.client(
                'route53',aws_region
            )
            # Query Route 53 for the current DNS record.
            if execution_mode == 'get_record':
                current_route53_record_set = route53_client.list_resource_record_sets(
                    HostedZoneId=route_53_zone_id,
                    StartRecordName=route_53_record_name,
                    StartRecordType=route_53_record_type,
                    MaxItems='2'
                )
                # boto3 returns a dictionary with a nested list of dictionaries
                # see: http://boto3.readthedocs.org/en/latest/reference/services/
                # route53.html#Route53.Client.list_resource_record_sets
                # Parse the dict to find the current IP for the hostname, if it exists.
                # If it doesn't exist, the function returns False.
                for eachRecord in current_route53_record_set['ResourceRecordSets']:
                    if eachRecord['Name'] == route_53_record_name:
                        # If there's a single record, pass it along.
                        if len(eachRecord['ResourceRecords']) == 1:
                            for eachSubRecord in eachRecord['ResourceRecords']:
                                current_route53_ip = eachSubRecord['Value']
                                return_status = 'success'
                                return_message = current_route53_ip
                                return {'return_status': return_status,
                                        'return_message': return_message}
                        # Error out if there is more than one value for the record set.
                        elif len(eachRecord['ResourceRecords']) > 1:
                            return_status = 'fail'
                            return_message = 'You should only have a single value for'\
                            ' your dynamic record.  You currently have more than one.'
                            return {'return_status': return_status,
                                    'return_message': return_message}

            # Set the DNS record to the current IP.
            if execution_mode == 'set_record':
                change_route53_record_set = route53_client.change_resource_record_sets(
                    HostedZoneId=route_53_zone_id,
                    ChangeBatch={
                        'Changes': [
                            {
                                'Action': 'UPSERT',
                                'ResourceRecordSet': {
                                    'Name': route_53_record_name,
                                    'Type': route_53_record_type,
                                    'TTL': route_53_record_ttl,
                                    'ResourceRecords': [
                                        {
                                            'Value': public_ip
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                )
                return 1
                
        def validate_hash(set_hostname, source_ip, validation_hash, shared_secret):
            # Calculate the validation hash.
            calculated_hash = hashlib.sha256(
                source_ip + set_hostname + shared_secret).hexdigest()
            # Compare the validation_hash from the client to the
            # calculated_hash.
            # If they don't match, error out.
            if not calculated_hash == validation_hash:
                return_status = 'fail'
                return_message = 'Validation hashes do not match.'
                return {'return_status': return_status,
                        'return_message': return_message}
            else:
                return_status = 'success'
                return_message = 'Validation hashes match.'
                return {'return_status': return_status,
                        'return_message': return_message}
                                        
        def run_list_hosts(set_hostname, record_type, validation_hash, source_ip):
            try:
                record_config_set = ddb_config(set_hostname, record_type, '', source_ip, 'read')
            except:
                return_status = 'fail'
                return_message = 'There was an issue finding '\
                    'or reading the DyanmoDB config item for '+set_hostname+': '+record_type
                return {'return_status': return_status,
                        'return_message': return_message}
            shared_secret = record_config_set['Item']['shared_secret']
            read_privilege = record_config_set['Item']['read_privilege']
            if not read_privilege :
                    return_status = 'fail'
                    return_message = 'record lacks read permissions'
                    return {'return_status': return_status,
                            'return_message': return_message}            
            validation_status = validate_hash(set_hostname, source_ip, validation_hash, shared_secret)
            if validation_status['return_status'] == 'fail':
                    return_status = validation_status['return_status']
                    return_message = validation_status['return_message']
                    return {'return_status': return_status,
                            'return_message': return_message}
                            
            dynamodb = boto3.resource('dynamodb')
            dynamodb_table = dynamodb.Table(ddns_config_table)
            dynamodb_response = dynamodb_table.query(
                IndexName='shared_secret-index',
                KeyConditionExpression=Key('shared_secret').eq(shared_secret),
                FilterExpression=Key('read_privilege').eq(True)
            )
            return_status = 'success'
            return_message = dynamodb_response['Items']
            # Strip unnecessary fields from response
            for record in return_message:
                del record['shared_secret']
                del record['read_privilege']
            return {'return_status': return_status,
                    'return_message': return_message}                            
                        
        ''' This function calls route53_set to see if the current Route 53 
            DNS record matches the client's current IP.
            If not it calls route53_set to set the DNS record to the current IP.
            It is called by the main lambda_handler function.
            '''
        def run_set_mode(set_hostname, record_type, validation_hash, source_ip, set_ip ):
            # Try to read the config, and error if you can't.
            try:
                record_config_set = ddb_config(set_hostname, record_type, '', source_ip, 'read')
            except:
                return_status = 'fail'
                return_message = 'There was an issue finding '\
                    'or reading the DyanmoDB config item for '+set_hostname+': '+record_type
                return {'return_status': return_status,
                        'return_message': return_message}
            # Check to see if the record is locked 
            lock_record = record_config_set['Item']['lock_record']
            if lock_record:
                return_status = 'fail'
                return_message = 'The record for ' + set_hostname + ' is locked, update denied.'
                return {'return_status': return_status,
                        'return_message': return_message}
              
            ## Deny update to internal IP if disallowed by DDB record.          
            allow_internal = record_config_set['Item']['allow_internal']
            if ( not allow_internal and not source_ip == set_ip):
                return_status = 'fail'
                return_message = 'DDB Permissions for ' + set_hostname + ' disallow internal IPs, update denied.'
                return {'return_status': return_status,
                        'return_message': return_message}

            route_53_zone_id = route_53_zone_id_imported
            
            ## Left for possible future multi-zone capability
            #aws_region = record_config_set['Item']['aws_region']
            ## the Route 53 Zone you created for the script
            #try:
            #  route_53_zone_id = record_config_set['Item']['zone_id']
            #except: 
            #  route_53_zone_id = route_53_zone_id_imported

            # record TTL (Time To Live) in seconds tells DNS servers how long to cache
            # the record.
            try:
              route_53_record_ttl = int(record_config_set['Item']['ttl'])
            except: 
              route_53_record_ttl = default_ttl
              
            route_53_record_type = record_config_set['Item']['record_type']
            shared_secret = record_config_set['Item']['shared_secret']

            # debug former validation hash check location
            
            validation_status = validate_hash(set_hostname, source_ip, validation_hash, shared_secret)
            if validation_status['return_status'] == 'fail':
                    return_status = validation_status['return_status']
                    return_message = validation_status['return_message']
                    return {'return_status': return_status,
                            'return_message': return_message}
            # If they do match, get the current ip address associated with
            # the hostname DNS record from Route 53.
            else:
                route53_get_response = route53_set(
                    'get_record',
                    aws_region,
                    route_53_zone_id,
                    set_hostname,
                    route_53_record_ttl,
                    route_53_record_type,
                    '')
                # If no records were found, route53_set returns null.
                # Set route53_ip and stop evaluating the null response.
                if not route53_get_response:
                    route53_ip = '0'
                # Pass the fail message up to the main function.
                elif route53_get_response['return_status'] == 'fail':
                    return_status = route53_get_response['return_status']
                    return_message = route53_get_response['return_message']
                    return {'return_status': return_status,
                            'return_message': return_message}
                else:
                    route53_ip = route53_get_response['return_message']
                # If the client's current IP matches the current DNS record
                # in Route 53 there is nothing left to do.
                if route53_ip == set_ip:
                    return_status = 'success'
                    return_message = 'Your IP address matches '\
                        'the current Route53 DNS record.'
                    return {'return_status': return_status,
                            'return_message': return_message}
                # If the IP addresses do not match or if the record does not exist,
                # Tell Route 53 to set the DNS record.
                # Then update the record in DynamoDB
                else:
                    return_status = route53_set(
                        'set_record',
                        aws_region,
                        route_53_zone_id,
                        set_hostname,
                        route_53_record_ttl,
                        route_53_record_type,
                        set_ip)
                    # Update DynamoDB with IP and update timestamp
                    ddb_config(set_hostname, route_53_record_type, set_ip, source_ip, 'write')
                    return_status = 'success'
                    return_message = 'Your hostname record ' + set_hostname +\
                        ' has been set to ' + set_ip
                    return {'return_status': return_status,
                            'return_message': return_message}

        ''' The function that Lambda executes.
            It contains the main script logic, calls 
            and returns the output back to API Gateway'''
        def lambda_handler(event, context):
            # Set event data from the API Gateway to variables.
            execution_mode = event['execution_mode']
            source_ip = event['source_ip']
            query_string = event['query_string']
            internal_ip = event['internal_ip']
            validation_hash = event['validation_hash']
            set_hostname = event['set_hostname']
            # Add a trailing . from the domain name to normalize the record key in DDB
            if not set_hostname.endswith('.'):
              set_hostname = set_hostname + '.'

            # Verify that the execution mode was set correctly.
            execution_modes = ('set', 'get', 'list_hosts')
            if execution_mode not in execution_modes:
                return_status = 'fail'
                return_message = 'You must pass mode=get, mode=set or mode=list_hosts arguments.'
                return_dict = {'return_status': return_status,
                               'return_message': return_message}
                               
            if not execution_mode == 'get':
                # Validate that the client passed a sha256 hash
                # regex checks for a 64 character hex string.
                if not re.match(r'[0-9a-fA-F]{64}', validation_hash):
                    return_status = 'fail'
                    return_message = 'You must pass a valid sha256 hash in the '\
                        'hash= argument.'
                    return {'return_status': return_status,
                            'return_message': return_message}
                # Check if internal_ip was set
                if internal_ip == "":
                    set_ip = source_ip
                else:
                    set_ip = internal_ip
                # Determine ipv4/ipv6, assumes AAAA if ipv4 regext does not match.
                if not re.match(r'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}', set_ip):
                  record_type = 'AAAA'
                else:
                  record_type = 'A'
                        
            if execution_mode == 'list_hosts':
                return_dict = run_list_hosts(set_hostname, record_type, validation_hash, source_ip)

            # Proceed with set mode to create or update the DNS record.
            elif execution_mode == 'set':
                return_dict = run_set_mode(set_hostname, record_type, validation_hash, source_ip, set_ip)
            else:
                # For get mode, reflect the client's public IP address and exit.
                # Assumes get since other choices exhausted
                return_status = 'success'
                return_message = source_ip
                return_dict = {'return_status': return_status,
                               'return_message': return_message}
                               
            # This Lambda function always exits as a success
            # and passes success or failure information in the json message.
            return return_dict

  ddnsCloudFrontAliased:
    Type: 'AWS::CloudFront::Distribution'
    Condition: cloudfrontAlias
    DependsOn: runSetup
    Properties:
      DistributionConfig:
        PriceClass: !FindInMap [cloudFrontPriceClassMapping, !Ref cloudFrontPriceClass, value]
        Origins:
          - DomainName: !Sub '${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com'
            Id: !Ref ddnsApi
            OriginPath: "/prod"
            CustomOriginConfig:
              HTTPSPort: '443'
              OriginProtocolPolicy: https-only
              OriginSSLProtocols: 
                - TLSv1.2
                - TLSv1.1
        Enabled: True
        Aliases: 
          - !Sub '${apiCname}.${route53ZoneName}'
        ViewerCertificate: 
          AcmCertificateArn: !Ref acmCertificateARN
          SslSupportMethod: 'sni-only' 
        DefaultCacheBehavior:
          TargetOriginId: !Ref ddnsApi
          ForwardedValues:
            QueryString: 'true'
          ViewerProtocolPolicy: redirect-to-https
          Compress: False
          DefaultTTL: 0
          MaxTTL: 0
          MinTTL: 0
        Comment: !Ref AWS::StackName
        HttpVersion: http2
        IPV6Enabled: True
      Tags:
        - Key: created-by
          Value: !Ref AWS::StackName

  ddnsCloudFront:
    Type: 'AWS::CloudFront::Distribution'
    Condition: cloudfrontNoAlias
    Properties:
      DistributionConfig:
        PriceClass: !FindInMap [cloudFrontPriceClassMapping, !Ref cloudFrontPriceClass, value]
        Origins:
          - DomainName: !Sub '${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com'
            Id: !Ref ddnsApi
            OriginPath: "/prod"
            CustomOriginConfig:
              HTTPSPort: '443'
              OriginProtocolPolicy: https-only
              OriginSSLProtocols: 
                - TLSv1.2
                - TLSv1.1
        Enabled: True
        DefaultCacheBehavior:
          TargetOriginId: !Ref ddnsApi
          ForwardedValues:
            QueryString: 'true'
          ViewerProtocolPolicy: redirect-to-https
          Compress: False
          DefaultTTL: 0
          MaxTTL: 0
          MinTTL: 0
        Comment: !Ref AWS::StackName
        HttpVersion: http2
        IPV6Enabled: True
      Tags:
        - Key: created-by
          Value: !Ref AWS::StackName
  ## Un-implemented as CloudFormation does not support dns validation for ACM (3/2018)
  # ddnsAcm:
  #   Type: AWS::CertificateManager::Certificate
  #   Properties:
  #     DomainName: !Sub '${apiCname}.${route53ZoneName}'
  #     DomainValidationOptions:
  #       - DomainName: !Sub '${apiCname}.${route53ZoneName}'
  #         ValidationDomain: !Ref route53ZoneName

  ddnsApi:
    Type: "AWS::ApiGateway::RestApi"
    Properties:
      Name: !Sub ${AWS::StackName}-api
      ApiKeySourceType: HEADER
      EndpointConfiguration: 
        Types: 
          - REGIONAL
      Body:
        swagger: 2.0
        info:
          title:
            Ref: AWS::StackName
        basePath: "/prod"
        schemes:
        - "https"
        paths:
          "/":
            get:
              consumes:
              - "application/json"
              produces:
              - "application/json"
              responses:
                "200":
                  description: "200 response"
                  schema:
                    $ref: "#/definitions/Empty"
              x-amazon-apigateway-integration:
                responses:
                  default:
                    statusCode: "200"
                uri: 
                  Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${lambdaDdnsFunction.Arn}/invocations
                passthroughBehavior: "when_no_match"
                httpMethod: "POST"
                requestTemplates:
                  application/json: "{\n    \"execution_mode\" : \"$input.params('mode')\"\
                    ,\n    \"source_ip\" : \"$context.identity.sourceIp\",\n    \"internal_ip\"\
                    \ : \"$input.params('internalIp')\",\n    \"query_string\" : \"$input.params().querystring\"\
                    ,\n    \"set_hostname\" : \"$input.params('hostname')\",\n    \"validation_hash\"\
                    \ : \"$input.params('hash')\"\n,\n    \"ipv6_address\"\
                    \ : \"$input.params('ipv6_address')\"\n}"
                type: "aws"
        definitions:
          Empty:
            type: "object"
            title: "Empty Schema"

  ddnsApiProdStage:
    Type: "AWS::ApiGateway::Stage"
    Properties:
      DeploymentId: !Ref ddnsApiDeployment
      MethodSettings:
        - HttpMethod: '*'
          ResourcePath: /*
      RestApiId: !Ref ddnsApi
      StageName: LATEST

  ddnsApiDeployment:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref 'ddnsApi'
      StageName: prod

## Work to build an API Key
#  apiGatewayUsagePlan:
#    Type: AWS::ApiGateway::UsagePlan
#    Properties:
#      ApiStages:
#      - ApiId: !Ref 'ddnsApi'
#        Stage: !Ref 'ddnsApiProdStage'
#      Description: Unlimited usage plan for API key
#      UsagePlanName: !Sub ${AWS::StackName}-usage-plan
#
#  apiKey: 
#    Type: "AWS::ApiGateway::ApiKey"
#    DependsOn: 
#      - "ddnsApiDeployment"
#      - "ddnsApi"
#      - "ddnsApiProdStage"
#    Properties: 
#      Name: !Sub ${AWS::StackName}-key
#      #Name: x-api-key
#      Description: "CloudFormation API Key V1"
#      Enabled: "true"
#      StageKeys: 
#        - RestApiId: !Ref 'ddnsApi'
#          StageName: !Ref 'ddnsApiProdStage'
#          
#  usagePlanKey:
#    Type: "AWS::ApiGateway::UsagePlanKey"
#    Properties : 
#      KeyId: !Ref 'apiKey'
#      KeyType: API_KEY
#      UsagePlanId: !Ref 'apiGatewayUsagePlan'
      
  lambdaDdnsRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-lambda-ddns
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-lambda-ddns
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Resource: "*"
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
              - Resource: !If [useExistingZone, !Sub 'arn:aws:route53:::hostedzone/${route53ZoneId}', !Sub 'arn:aws:route53:::hostedzone/${route53newZone}']
                Effect: Allow
                Action:
                  - route53:ListResourceRecordSets
                  - route53:ChangeResourceRecordSets
              - Resource: "arn:aws:route53:::change/*"
                Effect: Allow
                Action:
                  - route53:GetChange
              - Resource: !Sub arn:aws:s3:::${ddnsConfigBucket}/*
                Effect: Allow
                Action:
                  - s3:Get*
                  - s3:List*
                  - s3:PutObject
              - Resource: 
                  - !GetAtt ddnsConfigTable.Arn
                  - !Sub 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${ddnsConfigTable}/index/*'
                Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:BatchGetItem  
                  - dynamodb:PutItem 
                  - dynamodb:UpdateItem  
                  - dynamodb:Scan   
                  - dynamodb:Query
              # unused, allows cert creation
              #- Resource: "*"
              #  Effect: Allow
              #  Action:
              #    - acm:ListCertificates
              #    - acm:DescribeCertificate
              #    - acm:RequestCertificate

  apiGatewayRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-apigateway
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - apigateway.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-apigateway
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Resource: !GetAtt lambdaDdnsFunction.Arn
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
                  
  lambdaInvocationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ddnsApi}/*/GET/'
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      FunctionName: !GetAtt lambdaDdnsFunction.Arn

Outputs:
  apiUrl:
    Value:
      !If [enableCloudFront, !If [cloudfrontAlias, !Sub '${apiCname}.${route53ZoneName}', !GetAtt ddnsCloudFront.DomainName],  !Sub '${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com/prod']
    Description:
      The API URL to use in your client.
  apiOriginURL:
    Value:
      !Sub '${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com/prod'
    Description:
      API Gateway url, use for cname if manually implementing an API custom alias.
  cloudFrontURL:
    Value:
      !If [cloudfrontAlias, !GetAtt ddnsCloudFrontAliased.DomainName, !GetAtt ddnsCloudFront.DomainName]
    Description:
      CloudFront url, use for cname if manually implementing an API custom alias.
  route53ZoneName:
    Value:
      !Ref route53ZoneName
  route53ZoneID: 
    Value:
      !If [useExistingZone, !Ref route53ZoneId, !Ref route53newZone]
  DNSZoneNameServers: 
    Value:
      !If [createNewZone, !Join [ " ", !GetAtt route53newZone.NameServers ] , '' ]
    Description:
      Name Servers for DNS Zone if created by stack.  Use for delegation of subdomain.
#  apiKey: 
#    Value:
#      !Ref apiKey
#    Description:
#      Key required for API access.  Pass as http header x-api-key

  templateVersion:
     Value: 
      !Ref templateVersion