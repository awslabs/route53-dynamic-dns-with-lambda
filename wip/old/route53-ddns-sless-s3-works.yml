AWSTemplateFormatVersion: '2010-09-09'
Transform: 'AWS::Serverless-2016-10-31'

Description: Serverless dynamic DNS & device discovery service for ipv4 & ipv6
## Resource names are keyed off the Stack name, so multiple copies of the stack can be rn in the same Account & Region
## Based on http://docs.aws.amazon.com/iot/latest/developerguide/iot-button-cloudformation.html

Parameters:
  # Pipeline parameters
  route53ZoneName:
    Type: String
    Default: 'juno.net'
    Description: Route53 Zone
    # AllowedPattern: ^[a-zA-Z0-9]*$
    # ConstraintDescription: 

Resources:
  route53Zone: 
    Type: "AWS::Route53::HostedZone"
    Properties: 
      HostedZoneConfig: 
        Comment: !Sub Zone for ${AWS::StackName}
      Name: !Ref route53ZoneName
      HostedZoneTags: 
        - 
          Key: "CreatedBy"
          Value: !Ref AWS::StackName

  ddnsConfigTable:
    Type: AWS::Serverless::SimpleTable
    Properties:
      #Name: !Sub ${AWS::StackName}-config
      PrimaryKey:
        Name: hostname
        Type: String
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5

  ddnsConfigBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Join [ "-", [ !Ref "AWS::StackName", !Ref "AWS::Region", !Ref "AWS::AccountId"] ]
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
        - Id: Delete_Old_Versions
          NoncurrentVersionExpirationInDays: 90
          Status: Enabled

  lambdaDdnsFunction:
    Type: 'AWS::Serverless::Function'
    DependsOn: sourceToS3 
    Properties:
      FunctionName: !Sub ${AWS::StackName}-lambda-ddns
      Role: !GetAtt lambdaDdnsRole.Arn
      Timeout: 6
      Handler: index.lambda_handler
      Runtime: python2.7
      MemorySize: 512
      CodeUri:
         Bucket: !Ref ddnsConfigBucket
         Key: ddns_lambda.zip
         Version: !GetAtt sourceToS3.S3ObjectVersion
      Events:
        GetResource:
          Type: Api
          Properties:
            Path: /
            Method: get
            RestApiId: !Ref ddnsApi

  ddnsApi:
    Type: AWS::Serverless::Api
    DependsOn: lambdaDdnsFunction
    Properties:
        StageName: prod
        DefinitionBody:
            swagger: 2.0
            info:
              title:
                Ref: AWS::StackName
            paths:
              "/":
                get:
                  consumes:
                  - "application/json"
                  produces:
                  - "application/json"
                  responses:
                    "200":
                      description: "200 response"
                      schema:
                        $ref: "#/definitions/Empty"
                  x-amazon-apigateway-integration:
                    responses:
                      default:
                        statusCode: "200"
                    uri: 
                      Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${lambdaDdnsFunction.Arn}/invocations
                    passthroughBehavior: "when_no_match"
                    httpMethod: "POST"
                    requestTemplates:
                      application/json: "{\n    \"execution_mode\" : \"$input.params('mode')\"\
                        ,\n    \"source_ip\" : \"$context.identity.sourceIp\",\n    \"internal_ip\"\
                        \ : \"$input.params('internalIp')\",\n    \"query_string\" : \"$input.params().querystring\"\
                        ,\n    \"set_hostname\" : \"$input.params('hostname')\",\n    \"validation_hash\"\
                        \ : \"$input.params('hash')\"\n}"
                    type: "aws"
            definitions:
              Empty:
                type: "object"
                title: "Empty Schema"


  sourceToS3Lambda:
    Type: AWS::Lambda::Function
    DependsOn: ddnsConfigBucket
    Properties:
      FunctionName: !Sub ${AWS::StackName}-source-to-s3
      Handler: index.lambda_handler
      Runtime: python2.7
      Timeout: 30
      Role: !GetAtt lambdaDdnsRole.Arn
      Code:
        ZipFile: |
          from __future__ import print_function
          import boto3
          import os
          import zipfile
          import httplib
          import uuid
          import urlparse
          import json
          
          print('Loading function')
          
          from botocore.client import Config
          s3 = boto3.client('s3')
          
          def send_response(request, response, status=None, reason=None):
              """ Send our response to the pre-signed URL supplied by CloudFormation"""
              if status is not None:
                  response['Status'] = status
              if reason is not None:
                  response['Reason'] = reason
              if 'ResponseURL' in request and request['ResponseURL']:
                  url = urlparse.urlparse(request['ResponseURL'])
                  body = json.dumps(response)
                  https = httplib.HTTPSConnection(url.hostname)
                  https.request('PUT', url.path+'?'+url.query, body)
              return response
          
          def lambda_handler(event, context):
              response = {
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Status': 'SUCCESS'
              }
              # PhysicalResourceId is meaningless here, but CloudFormation requires it
              if 'PhysicalResourceId' in event:
                  response['PhysicalResourceId'] = event['PhysicalResourceId']
              else:
                  response['PhysicalResourceId'] = str(uuid.uuid4())
          
              # There is nothing to do for a delete request
              if event['RequestType'] == 'Delete':
                  return send_response(event, response)

              ## Get the S3 Bucket passed in from CFN
              s3TargetBucket=event['ResourceProperties']['s3TargetBucket']
              ## Get the file contents to put in S3 from CFN
              lambda_body=event['ResourceProperties']['lambda_body']

              ## Build the zip archive
              zip_archive = zipfile.ZipFile('/tmp/ddns_lambda.zip', 'w')
              #zip_archive.writestr('index.py', lambda_body)
              zip_archive.writestr('index.py', lambda_body)
              zip_archive.close()
              zip_file = open('/tmp/ddns_lambda.zip', 'r')
          
              ## Put the archive in S3
              try:
                  s3_response = s3.put_object(
                  Body= zip_file.read(),
                  Bucket= s3TargetBucket,
                  Key= "ddns_lambda.zip",
                  )
                  response['Data'] = {
                      's3Success': 'true',
                      'S3ObjectVersion': s3_response['VersionId']
                  }
                  response['Reason'] = 'ddns_lambda.zip added to S3'
                  #response['S3ObjectVersion'] = s3_response['VersionId']
                  #response['Data']['S3ObjectVersion']
                  print(str(s3_response['VersionId']))

              except Exception as E:
                response['Reason'] = 'Event Failed - See CloudWatch logs for the Lamba function backing the custom resource for details'
                ## Un-comment the line blow to send a true failure to CFN
                ## will cause a stack rollback on failure and can leave the stack in a state that requires deletion.
                #response['Status'] = 'FAILED'
              # Log it!
              print(str(s3_response))
              print('Response Text: ' + str(response))
              return send_response(event, response)

  ## Invoke the sourceToS3Lambda function and send the body text of files to put in S3
  ## Lambda-backed custom resources provisioned inline in CFN via the Zipfile method have a 4096 byte limit.  
  ## We pass the DDNS Lambda function code to sourceToS3Lambda which zips the code into S3 to avoid exceeding that limit.
  sourceToS3:
    Type: Custom::sourceToS3Lambda
    Properties:
      ServiceToken: !GetAtt sourceToS3Lambda.Arn
      Region: !Ref "AWS::Region"
      stackName: !Ref AWS::StackName
      s3TargetBucket: !Ref ddnsConfigBucket
      lambda_body: |
          #force function to run by changing this: 1
          # Dynamic DNS via AWS API Gateway, Lambda & Route 53
          # Script variables use lower_case
          
          from __future__ import print_function

          import json
          import re
          import hashlib
          import boto3

          # test log 
          # print('Lambda start: bar')

          # Tell the script where to find the configuration file.
          config_s3_region = 'us-west-2'
          config_s3_bucket = 'ddns-sless-us-west-2-456708182294'
          config_s3_key = 'config.json'

          def read_s3_config():
              # Define the S3 client.
              s3_client = boto3.client(
                  's3',
                  config_s3_region,
              )

              # Download the config to /tmp
              s3_client.download_file(
                  config_s3_bucket,
                  config_s3_key,
                  '/tmp/%s' % config_s3_key
              )
              # Open the config and return the json as a dictionary.
              full_config = (open('/tmp/%s' % config_s3_key).read())
              return json.loads(full_config)

          ''' This function defines the interaction with Route 53.
              It is called by the run_set_mode function.
              @param execution_mode defines whether to set or get a DNS record
              @param aws_region defines region to call
              @param route_53_zone_id defines the id for the DNS zone
              @param route_53_record_name defines the record, ie www.example.com.
              @param route_53_record_ttl defines defines the DNS record TTL
              @param route_53_record_type defines record type, should always be 'a'
              @param public_ip defines the current public ip of the client
              '''
          def route53_client(execution_mode, aws_region, route_53_zone_id,
                             route_53_record_name, route_53_record_ttl,
                             route_53_record_type, public_ip):
              # Define the Route 53 client
              route53_client = boto3.client(
                  'route53',
                  region_name=aws_region
              )

              # Query Route 53 for the current DNS record.
              if execution_mode == 'get_record':
                  current_route53_record_set = route53_client.list_resource_record_sets(
                      HostedZoneId=route_53_zone_id,
                      StartRecordName=route_53_record_name,
                      StartRecordType=route_53_record_type,
                      MaxItems='2'
                  )
                  # boto3 returns a dictionary with a nested list of dictionaries
                  # see: http://boto3.readthedocs.org/en/latest/reference/services/
                  # route53.html#Route53.Client.list_resource_record_sets
                  # Parse the dict to find the current IP for the hostname, if it exists.
                  # If it doesn't exist, the function returns False.
                  for eachRecord in current_route53_record_set['ResourceRecordSets']:
                      if eachRecord['Name'] == route_53_record_name:
                          # If there's a single record, pass it along.
                          if len(eachRecord['ResourceRecords']) == 1:
                              for eachSubRecord in eachRecord['ResourceRecords']:
                                  currentroute53_ip = eachSubRecord['Value']
                                  return_status = 'success'
                                  return_message = currentroute53_ip
                                  return {'return_status': return_status,
                                          'return_message': return_message}
                          # Error out if there is more than one value for the record set.
                          elif len(eachRecord['ResourceRecords']) > 1:
                              return_status = 'fail'
                              return_message = 'You should only have a single value for'\
                              ' your dynamic record.  You currently have more than one.'
                              return {'return_status': return_status,
                                      'return_message': return_message}

              # Set the DNS record to the current IP.
              if execution_mode == 'set_record':
                  change_route53_record_set = route53_client.change_resource_record_sets(
                      HostedZoneId=route_53_zone_id,
                      ChangeBatch={
                          'Changes': [
                              {
                                  'Action': 'UPSERT',
                                  'ResourceRecordSet': {
                                      'Name': route_53_record_name,
                                      'Type': route_53_record_type,
                                      'TTL': route_53_record_ttl,
                                      'ResourceRecords': [
                                          {
                                              'Value': public_ip
                                          }
                                      ]
                                  }
                              }
                          ]
                      }
                  )
                  return 1

          ''' This function calls route53_client to see if the current Route 53 
              DNS record matches the client's current IP.
              If not it calls route53_client to set the DNS record to the current IP.
              It is called by the main lambda_handler function.
              '''


          def run_set_mode(set_hostname, validation_hash, source_ip, internal_ip):
              # Try to read the config, and error if you can't.
              try:
                  full_config = read_s3_config()
              except:
                  return_status = 'fail'
                  return_message = 'There was an issue finding '\
                      'or reading the S3 config file.'
                  return {'return_status': return_status,
                          'return_message': return_message}
              # Check if internal_ip was set
              if internal_ip == "":
                  set_ip = source_ip
              else:
                  set_ip = internal_ip
              # Get the section of the config related to the requested hostname.
              record_config_set = full_config[set_hostname]
              aws_region = record_config_set['aws_region']
              # the Route 53 Zone you created for the script
              route_53_zone_id = record_config_set['route_53_zone_id']
              # record TTL (Time To Live) in seconds tells DNS servers how long to cache
              # the record.
              route_53_record_ttl = record_config_set['route_53_record_ttl']
              route_53_record_type = record_config_set['route_53_record_type']
              shared_secret = record_config_set['shared_secret']

              # Validate that the client passed a sha256 hash
              # regex checks for a 64 character hex string.
              if not re.match(r'[0-9a-fA-F]{64}', validation_hash):
                  return_status = 'fail'
                  return_message = 'You must pass a valid sha256 hash in the '\
                      'hash= argument.'
                  return {'return_status': return_status,
                          'return_message': return_message}

              # Calculate the validation hash.
              calculated_hash = hashlib.sha256(
                  source_ip + set_hostname + shared_secret).hexdigest()
              # Compare the validation_hash from the client to the
              # calculated_hash.
              # If they don't match, error out.
              if not calculated_hash == validation_hash:
                  return_status = 'fail'
                  return_message = 'Validation hashes do not match.'
                  return {'return_status': return_status,
                          'return_message': return_message}
              # If they do match, get the current ip address associated with
              # the hostname DNS record from Route 53.
              else:
                  route53_get_response = route53_client(
                      'get_record',
                      aws_region,
                      route_53_zone_id,
                      set_hostname,
                      route_53_record_ttl,
                      route_53_record_type,
                      '')
                  # If no records were found, route53_client returns null.
                  # Set route53_ip and stop evaluating the null response.
                  if not route53_get_response:
                      route53_ip = '0'
                  # Pass the fail message up to the main function.
                  elif route53_get_response['return_status'] == 'fail':
                      return_status = route53_get_response['return_status']
                      return_message = route53_get_response['return_message']
                      return {'return_status': return_status,
                              'return_message': return_message}
                  else:
                      route53_ip = route53_get_response['return_message']
                  # If the client's current IP matches the current DNS record
                  # in Route 53 there is nothing left to do.
                  if route53_ip == set_ip:
                      return_status = 'success'
                      return_message = 'Your IP address matches '\
                          'the current Route53 DNS record.'
                      return {'return_status': return_status,
                              'return_message': return_message}
                  # If the IP addresses do not match or if the record does not exist,
                  # Tell Route 53 to set the DNS record.
                  else:
                      return_status = route53_client(
                          'set_record',
                          aws_region,
                          route_53_zone_id,
                          set_hostname,
                          route_53_record_ttl,
                          route_53_record_type,
                          set_ip)
                      return_status = 'success'
                      return_message = 'Your hostname record ' + set_hostname +\
                          ' has been set to ' + set_ip
                      return {'return_status': return_status,
                              'return_message': return_message}


          ''' The function that Lambda executes.
              It contains the main script logic, calls 
              and returns the output back to API Gateway'''


          def lambda_handler(event, context):
              # Set event data from the API Gateway to variables.
              execution_mode = event['execution_mode']
              source_ip = event['source_ip']
              query_string = event['query_string']
              internal_ip = event['internal_ip']
              validation_hash = event['validation_hash']
              set_hostname = event['set_hostname']

              # Verify that the execution mode was set correctly.
              execution_modes = ('set', 'get')
              if execution_mode not in execution_modes:
                  return_status = 'fail'
                  return_message = 'You must pass mode=get or mode=set arguments.'
                  return_dict = {'return_status': return_status,
                                 'return_message': return_message}

              # For get mode, reflect the client's public IP address and exit.
              if execution_mode == 'get':
                  return_status = 'success'
                  return_message = source_ip
                  return_dict = {'return_status': return_status,
                                 'return_message': return_message}

              # Proceed with set mode to create or update the DNS record.
              else:
                  return_dict = run_set_mode(set_hostname, validation_hash, source_ip, internal_ip)

              # Log it    
              print('Response Text: ' + str(return_dict))

              # This Lambda function always exits as a success
              # and passes success or failure information in the json message.
              return return_dict

  lambdaDdnsRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-lambda-ddns
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-lambda-ddns
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Resource: "*"
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
              - Resource: !Sub arn:aws:route53:::hostedzone/${route53Zone}
                Effect: Allow
                Action:
                  - route53:ListResourceRecordSets
                  - route53:ChangeResourceRecordSets
              - Resource: "arn:aws:route53:::change/*"
                Effect: Allow
                Action:
                  - route53:GetChange
              - Resource: !Sub arn:aws:s3:::${ddnsConfigBucket}/*
                Effect: Allow
                Action:
                  - s3:Get*
                  - s3:List*
                  - s3:PutObject

  ## Unnecessary, built by Serverless
  # apiGatewayRole:
  #   Type: AWS::IAM::Role
  #   Properties:
  #     RoleName: !Sub ${AWS::StackName}-apigateway
  #     Path: /
  #     AssumeRolePolicyDocument:
  #       Version: 2012-10-17
  #       Statement:
  #       - Effect: Allow
  #         Principal:
  #           Service:
  #           - apigateway.amazonaws.com
  #         Action:
  #         - sts:AssumeRole
  #     Policies:
  #       - PolicyName: !Sub ${AWS::StackName}-apigateway
  #         PolicyDocument:
  #           Version: 2012-10-17
  #           Statement:
  #             - Resource: !GetAtt lambdaDdnsFunction.Arn
  #               Effect: Allow
  #               Action:
  #                 - lambda:InvokeFunction
  # lambdaInvocationPermission:
  #   Type: AWS::Lambda::Permission
  #   Properties:
  #     SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ddnsApi}/*/GET/'
  #     Action: lambda:InvokeFunction
  #     Principal: apigateway.amazonaws.com
  #     FunctionName: !GetAtt lambdaDdnsFunction.Arn
  #     SourceAccount: !Ref AWS::AccountId

Outputs:
  APIURL:
    Value:
      !Sub 'https://${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com/prod'
    Description:
      Full api url
  DNSZoneName:
    Value:
      !Ref route53ZoneName
  APICNAME:
    Value:
      !Sub 'https://api.${route53ZoneName}/prod'
    Description:
      CNAME for your api, auto-created in your zone.
  APIARN:
    Value:
      !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ddnsApi}/*/GET/'
  APIRootResourceId:
    Value:
      !GetAtt ddnsApi.RootResourceId
  DNSZoneID: 
    Value:
      !Ref route53Zone
  LambdaS3ObjectVersion:
    Value:
      !GetAtt sourceToS3.S3ObjectVersion
    Description:
      Object version of Lambda package zip in s3.
  DNSZoneNameServers: 
    Value:
      !Join [ " ", !GetAtt route53Zone.NameServers ] 
    Description:
      Name Servers for DNS Zone.  Use for delegation of subdomain.