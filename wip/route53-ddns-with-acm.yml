## this version creates the ACM cert.
## Backed out from final release- too complex and likely to fail
AWSTemplateFormatVersion: '2010-09-09'
Description: Serverless dynamic DNS & device discovery service for ipv4 & ipv6
## Resource names are keyed off the Stack name.

Parameters:
  route53ZoneName:
    Type: String
    Default: 'greathou.se'
    Description: "Required: Route53 Zone, either existing or name to be created. -- Must not end in '.' -- If it's an existing zone, it must match the zone id passed in route53ZoneId."
    #AllowedPattern: ^([a-zA-Z0-9-].)+[a-zA-Z0-9-]$  #commented out to support unicode
    
  route53ZoneId:
    Type: String
    Default: 'Z2PXLQ1OBZKR4O'
    Description: Populate to use existing zone.  ie 'Z1FXLQ1OABKR4O' Must be from the same account. --  If omitted, a new zone will be created.  -- If supplied, the ddns system will get IAM permissions to modify existing zone entries.

  defaultTtl:
    Type: String
    Default: 60
    Description: Default DNS record TTL, can be overridden for individual records in DynamoDB config.
    
  apiCname:
    Type: String
    Default: 'ddns'
    Description: "API Endpoint Custom Alias.  Required for enableCloudFront:withCustomAlias"
    #AllowedPattern: ^[a-zA-Z0-9]*$ #commented out to support unicode
    
  enableCloudFront:
    Default: false
    Type: String
    AllowedValues: [false, withCustomAlias, withoutCustomAlias]
    Description: "CloudFront is required for ipv6 or to use a custom dns endpoint (Alias) for your API."
    
#  enableIpv6:
#    Default: true
#    Type: String
#    AllowedValues: [true, false]
#    Description: If true, build a CloudFront distribution to use as an ipv6/ipv4 endpoint.
    
  acmCertificateARN:
    Default: 'arn:aws:acm:us-east-1:434941873588:certificate/64fba4c1-86dc-43a3-9942-fc9b6ca24bb6'
    Type: String
    Description: "Populate to use existing ACM Certificate: Full ARN of an ACM SSL Certificate in us-east-1 Region.  -- i.e. arn:aws:acm:us-east-1:123456789012:certificate/a1aaab22-11ab-ab12-cd34-12345abc0ab0"
    
  templateVersion:
    Type: String
    Default: 1
    Description: "For debugging, increment this parameter to force CFN to re-run the template"
    ## Uses a matching output to force the update

Metadata: 
  AWS::CloudFormation::Interface: 
    ParameterGroups: 
      - 
        Label: 
          default: "DNS Zone:"
        Parameters: 
          - route53ZoneName
          - route53ZoneId
          - defaultTtl
      - 
        Label: 
          default: "CloudFront Configuration:"
        Parameters: 
          - enableCloudFront
          - apiCname
          - acmCertificateARN
                     
Conditions:
    #debugCond: !Equals [ !Ref route53ZoneId , '8675309']
    useExistingZone: !Not [!Equals [ !Ref route53ZoneId , '']]
    createNewZone: !Not [Condition: useExistingZone]
    ## Build a CF dist with alias if:
    ## enableCloudFront:withCustomAlias & apiCname is not empty 
    cloudfrontAlias: !And 
        - !Equals [ !Ref enableCloudFront , 'withCustomAlias']
        - !Not [!Equals [ !Ref apiCname , '']]
    cloudfrontNoAlias: !Equals [ !Ref enableCloudFront , 'withoutCustomAlias']
    enableCloudFront: !Or [ Condition: cloudfrontAlias, Condition: cloudfrontNoAlias]
    useExistingCert: !Not [!Equals [ !Ref acmCertificateARN , '']]

#    enableIpv6: !Equals [ !Ref enableIpv6 , 'true']
#    cloudfrontAlias: !And [!Not [!Equals [ !Ref apiCname , '']], !Not [!Equals [ !Ref acmCertificateARN , '']]]
#    cloudfrontNoAlias: !And [!Not [Condition: cloudfrontAlias], Condition: enableIpv6]
#    enableCloudFront: !Or [ Condition: cloudfrontAlias, Condition: cloudfrontNoAlias]
         
Resources:
  route53newZone: 
    Type: "AWS::Route53::HostedZone"
    Condition: createNewZone
    Properties: 
      HostedZoneConfig: 
        Comment: !Sub Zone for ${AWS::StackName}
      Name: !Ref route53ZoneName
      HostedZoneTags: 
        - 
          Key: "CreatedBy"
          Value: !Ref AWS::StackName

  ddnsConfigTable: 
    Type: "AWS::DynamoDB::Table"
    Properties: 
      TableName: !Sub ${AWS::StackName}-config
      AttributeDefinitions: 
        - 
          AttributeName: "hostname"
          AttributeType: "S"
        - 
          AttributeName: "record_type"
          AttributeType: "S"
      KeySchema: 
        - 
          AttributeName: "hostname"
          KeyType: "HASH"
        - 
          AttributeName: "record_type"
          KeyType: "RANGE"
      ProvisionedThroughput: 
        ReadCapacityUnits: "5"
        WriteCapacityUnits: "5"

  ddnsConfigBucket:
    Type: "AWS::S3::Bucket"
    Properties:
      BucketName: !Join [ "-", [ !Ref "AWS::StackName", !Ref "AWS::Region", !Ref "AWS::AccountId"] ]
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
        - Id: Delete_Old_Versions
          NoncurrentVersionExpirationInDays: 90
          Status: Enabled

  lambdaDdnsFunction:
    Type: "AWS::Lambda::Function"
    DependsOn: ddnsSourceToS3
    Properties:
      FunctionName: !Sub ${AWS::StackName}-ddns
      Handler: index.lambda_handler
      Runtime: python2.7
      MemorySize: 512
      Timeout: 30
      Role: !GetAtt lambdaDdnsRole.Arn
      Environment:
        Variables:
          ddns_config_table: !Ref ddnsConfigTable
          route_53_zone_id: !If [useExistingZone, !Ref route53ZoneId, !Ref route53newZone]
          route_53_zone_name: !Ref route53ZoneName
          default_ttl: !Ref defaultTtl
      Code:
        S3Bucket: !Ref ddnsConfigBucket
        S3Key: ddns_lambda.zip
        S3ObjectVersion: !GetAtt ddnsSourceToS3.ddns_lambda-S3ObjectVersion

  setupLambda:
    Type: AWS::Lambda::Function
    DependsOn: 
        - ddnsConfigTable 
        - lambdaDdnsRole
    Properties:
      FunctionName: !Sub ${AWS::StackName}-setup
      Handler: index.lambda_handler
      Runtime: python2.7
      Timeout: 30
      Role: !GetAtt lambdaDdnsRole.Arn
      Environment:
        Variables:
          ddns_config_table: !Ref ddnsConfigTable
          route_53_zone_id: !If [useExistingZone, !Ref route53ZoneId, !Ref route53newZone]
          route_53_zone_name: !Ref route53ZoneName
          aws_region: !Ref AWS::Region
          api_cname: !If [cloudfrontAlias, !Sub '${apiCname}.${route53ZoneName}', '']
          #api_cname: !If [cloudfrontAlias, !Ref apiCname, '']
          # debug
          #create_acm: 'true'
          create_acm: !If [cloudfrontAlias, 'true', 'false']
          #api_origin: !Sub '${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com/prod'
      Code:
        S3Bucket: !Ref ddnsConfigBucket
        S3Key: setup_lambda.zip
        S3ObjectVersion: !GetAtt setupSourceToS3.setup_lambda-S3ObjectVersion

  runSetup:
    Type: Custom::setupLambda
    DependsOn: setupLambda
    Properties:
      ServiceToken: !GetAtt setupLambda.Arn
      Region: !Ref AWS::Region
      stackName: !Ref AWS::StackName
      forceUpdate: !Ref templateVersion
      run_mode: 'first_run'
      cloudfront_url: ''
      
  runSetupSecondRun:
    Type: Custom::setupLambda
    #Condition: debugCond
    Condition: cloudfrontAlias
    DependsOn: 
      - setupLambda
      - ddnsCloudFrontAliased
    Properties:
      ServiceToken: !GetAtt setupLambda.Arn
      Region: !Ref AWS::Region
      stackName: !Ref AWS::StackName
      forceUpdate: !Ref templateVersion
      run_mode: 'second_run'
      #cloudfront_url: 'debug.foo.com'
      cloudfront_url: !GetAtt ddnsCloudFrontAliased.DomainName
      
  sourceToS3Lambda:
    Type: AWS::Lambda::Function
    DependsOn: ddnsConfigBucket
    Properties:
      FunctionName: !Sub ${AWS::StackName}-source-to-s3
      Handler: index.lambda_handler
      Runtime: python2.7
      Timeout: 30
      Role: !GetAtt lambdaDdnsRole.Arn
      Code:
        ZipFile: |
          from __future__ import print_function
          import boto3
          import os
          import zipfile
          import httplib
          import uuid
          import urlparse
          import json
           
          print('Loading function')
          from botocore.client import Config
          s3 = boto3.client('s3')
          
          def send_response(request, response, status=None, reason=None):
              """ Send our response to the pre-signed URL supplied by CloudFormation"""
              if status is not None:
                  response['Status'] = status
              if reason is not None:
                  response['Reason'] = reason
              if 'ResponseURL' in request and request['ResponseURL']:
                  url = urlparse.urlparse(request['ResponseURL'])
                  body = json.dumps(response)
                  https = httplib.HTTPSConnection(url.hostname)
                  https.request('PUT', url.path+'?'+url.query, body)
              return response
          
          def lambda_handler(event, context):
              response = {
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Status': 'SUCCESS'
              }
              # PhysicalResourceId is meaningless here, but CloudFormation requires it
              if 'PhysicalResourceId' in event:
                  response['PhysicalResourceId'] = event['PhysicalResourceId']
              else:
                  response['PhysicalResourceId'] = str(uuid.uuid4())
          
              # There is nothing to do for a delete request
              if event['RequestType'] == 'Delete':
                  return send_response(event, response)
              ## Get the S3 Bucket passed in from CFN
              s3TargetBucket=event['ResourceProperties']['s3TargetBucket']
              ## Get the file contents to put in S3 from CFN
              lambda_body=event['ResourceProperties']['lambda_body']
              file_name=event['ResourceProperties']['file_name']
              zip_file = '/tmp/' + file_name + '.zip'
              s3_key = file_name + '.zip'
              ## Write the body variable to a file
              ## and change perms to add exec
              try:
                os.remove('/tmp/index.py') # delete old file in case function is re-used
              except:
                pass
              lambda_file = open('/tmp/index.py', 'w')
              os.chmod('/tmp/index.py', 0777)
              lambda_file.write(lambda_body)
              lambda_file.close()
              ## Build the zip archive
              zip_archive = zipfile.ZipFile(zip_file, 'w')
              zip_archive.write('/tmp/index.py', 'index.py')
              zip_archive.close()
              zip_file = open(zip_file, 'r')
          
              ## Put the archive in S3
              try:
                  s3_response = s3.put_object(
                  Body= zip_file.read(),
                  Bucket= s3TargetBucket,
                  Key= s3_key,
                  )
                  response['Data'] = {
                      's3Success': 'true',
                      file_name + '-S3ObjectVersion': s3_response['VersionId']
                  }
                  response['Reason'] = s3_key + ' added to S3'
                  print(str(s3_response['VersionId']))
              except Exception as E:
                response['Reason'] = 'Event Failed - See CloudWatch logs for the Lamba function backing the custom resource for details'
                ## Un-comment the line below to send a true failure to CFN
                ## will cause a stack rollback on failure and can leave the stack in a state that requires deletion.
                #response['Status'] = 'FAILED'
              # Log it!
              print(str(s3_response))
              print('Response Text: ' + str(response))
              return send_response(event, response)


  ## Invoke the sourceToS3Lambda function and send the body text of files to put in S3
  ## Lambda-backed custom resources provisioned inline in CFN via the Zipfile method have a 4096 byte limit.  
  ## We pass the DDNS Lambda function code to sourceToS3Lambda which zips the code into S3 to avoid exceeding that limit.
  
  setupSourceToS3:
    Type: Custom::sourceToS3Lambda
    DependsOn: sourceToS3Lambda
    Properties:
      ServiceToken: !GetAtt sourceToS3Lambda.Arn
      Region: !Ref "AWS::Region"
      stackName: !Ref AWS::StackName
      s3TargetBucket: !Ref ddnsConfigBucket
      file_name: 'setup_lambda'
      lambda_body: |
            #force function to run by changing this: 0
            from __future__ import print_function
            import boto3
            import datetime  
            import random
            import os   
            import uuid
            import httplib
            import urlparse
            import json
            import time
            
            print('Loading function')
            from botocore.client import Config
            from botocore.exceptions import ClientError
            
            # Import Lambda environment variables
            ddns_config_table = os.environ['ddns_config_table']
            route_53_zone_id = os.environ['route_53_zone_id']
            route_53_zone_name = os.environ['route_53_zone_name']
            aws_region = os.environ['aws_region']
            api_cname = os.environ['api_cname']
            create_acm = os.environ['create_acm']
            #api_origin = os.environ['api_origin']
            #Add a trailing '.' if not present.
            #if not route_53_zone_name.endswith('.'):
            #    route_53_zone_name = route_53_zone_name + '.'
            def send_response(request, response, status=None, reason=None):
                """ Send our response to the pre-signed URL supplied by CloudFormation"""
                if status is not None:
                    response['Status'] = status
                if reason is not None:
                    response['Reason'] = reason
                if 'ResponseURL' in request and request['ResponseURL']:
                    url = urlparse.urlparse(request['ResponseURL'])
                    body = json.dumps(response)
                    https = httplib.HTTPSConnection(url.hostname)
                    https.request('PUT', url.path+'?'+url.query, body)
                    # debug
                    print(url.hostname)
                    print('PUT', url.path+'?'+url.query, body)
                print(response)
                return response
            
            def route53_set(aws_region, route_53_zone_id,
                               route_53_record_name, route_53_record_ttl,
                               route_53_record_type, route_53_record_value):
                # Define the Route 53 client
                route53_client = boto3.client(
                    'route53',aws_region
                )
                change_route53_record_set = route53_client.change_resource_record_sets(
                    HostedZoneId=route_53_zone_id,
                    ChangeBatch={
                        'Changes': [
                            {
                                'Action': 'UPSERT',
                                'ResourceRecordSet': {
                                    'Name': route_53_record_name,
                                    'Type': route_53_record_type,
                                    'TTL': route_53_record_ttl,
                                    'ResourceRecords': [
                                        {
                                            'Value': route_53_record_value
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                )
                return change_route53_record_set
            
            def acm_find(route_53_zone_name):
                acm_client = boto3.client('acm', region_name='us-east-1')
                cert_list = acm_client.list_certificates()
                for my_cert in (cert_list['CertificateSummaryList']):
                    if (str(my_cert['DomainName'])) == str(route_53_zone_name) :
                        return (my_cert['CertificateArn'])
                return 'fail'
                
            def acm_request(api_cname):
                acm_client = boto3.client('acm', region_name='us-east-1')
                ## Ensure there is no trailing '.' for ACM
                route_53_zone_name=api_cname.rstrip('.')
                cert_request = acm_client.request_certificate(
                    DomainName=api_cname,
                    ValidationMethod='DNS',
                    DomainValidationOptions=[
                        {
                            'DomainName': api_cname,
                            'ValidationDomain': api_cname
                        },
                    ]
                )
                cert_arn=(cert_request['CertificateArn'])
                return cert_arn
                
            def acm_info(cert_arn):
                ## ACM certs for CloudFront need to be in us-east-1
                acm_client = boto3.client('acm', region_name='us-east-1')
                try:
                    cert_info = acm_client.describe_certificate(
                        CertificateArn=cert_arn
                    )
                    cert_validation_status=(cert_info['Certificate']['DomainValidationOptions'][0]['ValidationStatus'])
                    cert_validation_name=(cert_info['Certificate']['DomainValidationOptions'][0]['ResourceRecord']['Name'])
                    cert_validation_value=(cert_info['Certificate']['DomainValidationOptions'][0]['ResourceRecord']['Value'])
                    return {'cert_arn': cert_arn, 'cert_validation_name': cert_validation_name, 'cert_validation_value': cert_validation_value, 'cert_validation_status': cert_validation_status}
                except:
                    return 'fail'
            
            def run_acm_process(route_53_zone_name, api_cname, api_origin):
                ## Look to see if certificate already exists
                existing_cert = acm_find(api_cname)
                if existing_cert == 'fail':
                    cert_arn = ''
                    pass
                else:
                    cert_arn = existing_cert
                    print('Found existing cert: ' + cert_arn)
                
                ## If cert does not already exist, create it.
                if cert_arn == '':
                    cert_arn = acm_request(api_cname)
                    print('Created new cert: ' + str(cert_arn))
                try:
                    ## Loop with exp backoff to get the ACM DNS validation records
                    for loop_count in range(1, 6):
                        time.sleep(loop_count*5)
                        print("ACM creation info attempt: " + str(loop_count))
                        acm_return_dict = acm_info(cert_arn)
                        if acm_return_dict != 'fail' :
                            break
                except:
                    print('Failed to create Route53 DNS validation record.')
                cert_validation_name = (acm_return_dict['cert_validation_name'])
                cert_validation_value = (acm_return_dict['cert_validation_value'])
                print("Setting validation record: " + cert_validation_name + " CNAME " + cert_validation_value)
                ## ACM validation records are always the same for any zone.
                ## Create the validation record regardless of whether the cert existed before.
                route_53_return_dict = route53_set(aws_region, route_53_zone_id, cert_validation_name, 300, 'CNAME', cert_validation_value)
                try:
                    ## Loop with exp backoff to pause until the cert is validated
                    for loop_count in range(1, 6):
                        time.sleep(loop_count*5)
                        print("ACM validation info attempt: " + str(loop_count))
                        acm_return_dict = acm_info(cert_arn)
                        if acm_return_dict['cert_validation_status'] == 'SUCCESS':
                            break
                except:
                    print('ACM Certificate failed to validate.')
                return cert_arn 
               
            def populate_ddb(ddns_config_table, route_53_zone_name):
                try:
                    # Define the DDB client.
                    dynamodb = boto3.resource('dynamodb')
                    dynamodb_table = dynamodb.Table(ddns_config_table)
                    dynamodb_table.put_item(
                      Item={
                      'hostname': 'example-record.' + route_53_zone_name + '.', 
                      'record_type': 'A',
                      'aws_region': aws_region,
                      'zone_id': route_53_zone_id, 
                      'ttl': 60,
                      'shared_secret': ''.join(random.choice('0123456789ABCDEF') for i in range(16)),
                      'lock_record': False, 
                      'ip_address': '1.1.1.1', 
                      'last_checked': str(datetime.datetime.now()), 
                      'last_updated': str(datetime.datetime.now()),
                      'comment': 'sample comment'
                      }
                    )
                    dynamodb_table.put_item(
                      Item={
                      'hostname': 'example-record.' + route_53_zone_name + '.', 
                      'record_type': 'AAAA',
                      'aws_region': aws_region,
                      'zone_id': route_53_zone_id, 
                      'ttl': 60,
                      'shared_secret': ''.join(random.choice('0123456789ABCDEF') for i in range(16)), 
                      'lock_record': False, 
                      'ip_address': '2001:564:6045:96:d66:c133:2ab3:7b01', 
                      'last_checked': str(datetime.datetime.now()), 
                      'last_updated': str(datetime.datetime.now()),
                      'comment': 'sample comment'
                      }
                    )
                    print('Populated sample DDB entries')
                except:
                    print('Failed to populate sample DDB entries')
                  
            ## Main Lambda handler
            def lambda_handler(event, context):
                response = {
                    'StackId': event['StackId'],
                    'RequestId': event['RequestId'],
                    'LogicalResourceId': event['LogicalResourceId'],
                    'Status': 'SUCCESS'
                }
                ## Pass the run mode argument so lambda can tell if this is the first setup run,
                ## Or the second run (post CF creation) that cnames CloudFront
                run_mode=event['ResourceProperties']['run_mode']
                cloudfront_url=event['ResourceProperties']['cloudfront_url']
                # PhysicalResourceId is meaningless here, but CloudFormation requires it
                if 'PhysicalResourceId' in event:
                    response['PhysicalResourceId'] = event['PhysicalResourceId']
                else:
                    response['PhysicalResourceId'] = str(uuid.uuid4())
            
                # There is nothing to do for a delete request
                if event['RequestType'] == 'Delete':
                    return send_response(event, response)
                    
                ## Main function logic    
                try:  
                  print('Run mode: '+run_mode)
                  if run_mode == 'first_run':
                    populate_ddb(ddns_config_table, route_53_zone_name)
                    if create_acm == 'true' :
                        cert_arn = run_acm_process(route_53_zone_name, api_cname, cloudfront_url)
                        response['Data'] = {
                          'acmCertificateARN': cert_arn
                        }
                        print('Using certificate: ' + cert_arn)
                        
                  elif run_mode == 'second_run':
                    print("Setting api CloudFront cname: " + api_cname + " CNAME " + cloudfront_url)
                    route_53_return_dict = route53_set(aws_region, route_53_zone_id, api_cname, 300, 'CNAME', cloudfront_url)
                  response['Reason'] = 'Event Succeeded'
                except ClientError as e:
                  print("Unexpected error: %s" % e)
                  response['Reason'] = 'Event Failed - See CloudWatch logs for the Lamba function backing the custom resource for details'
                  ## Un-comment the line blow to send a true failure to CFN
                  ## will cause a stack rollback on failure and can leave the stack in a state that requires deletion.
                  #response['Status'] = 'FAILED'
                return send_response(event, response)


  ddnsSourceToS3:
    Type: Custom::sourceToS3Lambda
    DependsOn: sourceToS3Lambda
    Properties:
      ServiceToken: !GetAtt sourceToS3Lambda.Arn
      Region: !Ref "AWS::Region"
      stackName: !Ref AWS::StackName
      s3TargetBucket: !Ref ddnsConfigBucket
      file_name: 'ddns_lambda'
      lambda_body: |
        #force function to run by changing this: 0
        # version works with DDB
        # Dynamic DNS via AWS API Gateway, Lambda & Route 53
        # Script variables use lower_case_
        from __future__ import print_function

        import json
        import re
        import hashlib
        import boto3
        import datetime
        import os

        # Import Lambda environment variables
        ddns_config_table = os.environ['ddns_config_table']
        route_53_zone_id_imported = os.environ['route_53_zone_id']
        route_53_zone_name_imported = os.environ['route_53_zone_name']
        default_ttl = int(os.environ['default_ttl'])

        ''' This function pulls the config entry from DynamoDB 
            It is called by the run_set_mode function.'''
        def ddb_config(route_53_record_name, route_53_record_type, set_ip, read_write):
            # Define the DDB client.
            #print(route_53_record_name + route_53_record_type)
            dynamodb = boto3.resource('dynamodb')
            dynamodb_table = dynamodb.Table(ddns_config_table)
            if read_write == 'read':
              try:
                config_record = dynamodb_table.get_item(
                    Key={
                    'hostname': route_53_record_name,
                    'record_type': route_53_record_type
                    })
                dynamodb_table.update_item(
                    Key={
                    'hostname': route_53_record_name,
                    'record_type': route_53_record_type
                    },
                    UpdateExpression='SET last_checked = :now_time',
                    ConditionExpression='attribute_exists(hostname) AND attribute_exists(record_type)',
                    ExpressionAttributeValues={
                        ':now_time': str(datetime.datetime.now())
                    }
                    #ConditionExpression='lock_record = :locked', ':locked': {'BOOL': False }
                )
              except:
                return_status = 'fail'
                return_message = 'ddb_config There was an issue finding '\
                    'or reading the DyanmoDB config item for '+set_hostname+': '+record_type
                return {'return_status': return_status,
                        'return_message': return_message}

              #print(str(config_record))
              return config_record
            elif read_write == 'write':
                dynamodb_table.update_item(
                    Key={
                    'hostname': route_53_record_name,
                    'record_type': route_53_record_type                      },
                    UpdateExpression='SET last_updated = :now_time , ip_address = :ip ',
                    ExpressionAttributeValues={
                        ':now_time': str(datetime.datetime.now()),
                        ':ip': set_ip
                    },
                    ConditionExpression='attribute_exists(hostname) AND attribute_exists(record_type)'
                )
                return

        ''' This function defines the interaction with Route 53.
            It is called by the run_set_mode function.
            @param execution_mode defines whether to set or get a DNS record
            @param aws_region defines region to call
            @param route_53_zone_id defines the id for the DNS zone
            @param route_53_record_name defines the record, ie www.acme.com.
            @param route_53_record_ttl defines defines the DNS record TTL
            @param route_53_record_type defines record type, should always be 'a'
            @param public_ip defines the current public ip of the client
            '''
        def route53_set(execution_mode, aws_region, route_53_zone_id,
                           route_53_record_name, route_53_record_ttl,
                           route_53_record_type, public_ip):
            # Define the Route 53 client
            route53_client = boto3.client(
                'route53',aws_region
            )
            ## debug                 region_name=aws_region

            # Query Route 53 for the current DNS record.
            if execution_mode == 'get_record':
                current_route53_record_set = route53_client.list_resource_record_sets(
                    HostedZoneId=route_53_zone_id,
                    StartRecordName=route_53_record_name,
                    StartRecordType=route_53_record_type,
                    MaxItems='2'
                )
                # boto3 returns a dictionary with a nested list of dictionaries
                # see: http://boto3.readthedocs.org/en/latest/reference/services/
                # route53.html#Route53.Client.list_resource_record_sets
                # Parse the dict to find the current IP for the hostname, if it exists.
                # If it doesn't exist, the function returns False.
                for eachRecord in current_route53_record_set['ResourceRecordSets']:
                    if eachRecord['Name'] == route_53_record_name:
                        # If there's a single record, pass it along.
                        if len(eachRecord['ResourceRecords']) == 1:
                            for eachSubRecord in eachRecord['ResourceRecords']:
                                currentroute53_ip = eachSubRecord['Value']
                                return_status = 'success'
                                return_message = currentroute53_ip
                                return {'return_status': return_status,
                                        'return_message': return_message}
                        # Error out if there is more than one value for the record set.
                        elif len(eachRecord['ResourceRecords']) > 1:
                            return_status = 'fail'
                            return_message = 'You should only have a single value for'\
                            ' your dynamic record.  You currently have more than one.'
                            return {'return_status': return_status,
                                    'return_message': return_message}

            # Set the DNS record to the current IP.
            if execution_mode == 'set_record':
                change_route53_record_set = route53_client.change_resource_record_sets(
                    HostedZoneId=route_53_zone_id,
                    ChangeBatch={
                        'Changes': [
                            {
                                'Action': 'UPSERT',
                                'ResourceRecordSet': {
                                    'Name': route_53_record_name,
                                    'Type': route_53_record_type,
                                    'TTL': route_53_record_ttl,
                                    'ResourceRecords': [
                                        {
                                            'Value': public_ip
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                )
                return 1

        ''' This function calls route53_set to see if the current Route 53 
            DNS record matches the client's current IP.
            If not it calls route53_set to set the DNS record to the current IP.
            It is called by the main lambda_handler function.
            '''
        def run_set_mode(set_hostname, record_type, validation_hash, source_ip, set_ip ):
            # Try to read the config, and error if you can't.
            try:
                record_config_set = ddb_config(set_hostname, record_type, '', 'read')
            except:
                return_status = 'fail'
                return_message = 'There was an issue finding '\
                    'or reading the DyanmoDB config item for '+set_hostname+': '+record_type
                return {'return_status': return_status,
                        'return_message': return_message}
            # Check to see if the record is locked
            lock_record = record_config_set['Item']['lock_record']
            if lock_record:
                return_status = 'fail'
                return_message = 'The record for ' + set_hostname + ' is locked, update denied.'
                return {'return_status': return_status,
                        'return_message': return_message}

            aws_region = record_config_set['Item']['aws_region']
            # the Route 53 Zone you created for the script
            try:
              route_53_zone_id = record_config_set['Item']['zone_id']
            except: 
              route_53_zone_id = route_53_zone_id_imported

            # record TTL (Time To Live) in seconds tells DNS servers how long to cache
            # the record.
            try:
              route_53_record_ttl = int(record_config_set['Item']['ttl'])
            except: 
              route_53_record_ttl = default_ttl
              
            route_53_record_type = record_config_set['Item']['record_type']
            shared_secret = record_config_set['Item']['shared_secret']

            # Validate that the client passed a sha256 hash
            # regex checks for a 64 character hex string.
            if not re.match(r'[0-9a-fA-F]{64}', validation_hash):
                return_status = 'fail'
                return_message = 'You must pass a valid sha256 hash in the '\
                    'hash= argument.'
                return {'return_status': return_status,
                        'return_message': return_message}

            # Calculate the validation hash.
            calculated_hash = hashlib.sha256(
                source_ip + set_hostname + shared_secret).hexdigest()
            # Compare the validation_hash from the client to the
            # calculated_hash.
            # If they don't match, error out.
            if not calculated_hash == validation_hash:
                return_status = 'fail'
                return_message = 'Validation hashes do not match.'
                return {'return_status': return_status,
                        'return_message': return_message}
            # If they do match, get the current ip address associated with
            # the hostname DNS record from Route 53.
            else:
                route53_get_response = route53_set(
                    'get_record',
                    aws_region,
                    route_53_zone_id,
                    set_hostname,
                    route_53_record_ttl,
                    route_53_record_type,
                    '')
                # If no records were found, route53_set returns null.
                # Set route53_ip and stop evaluating the null response.
                if not route53_get_response:
                    route53_ip = '0'
                # Pass the fail message up to the main function.
                elif route53_get_response['return_status'] == 'fail':
                    return_status = route53_get_response['return_status']
                    return_message = route53_get_response['return_message']
                    return {'return_status': return_status,
                            'return_message': return_message}
                else:
                    route53_ip = route53_get_response['return_message']
                # If the client's current IP matches the current DNS record
                # in Route 53 there is nothing left to do.
                if route53_ip == set_ip:
                    return_status = 'success'
                    return_message = 'Your IP address matches '\
                        'the current Route53 DNS record.'
                    return {'return_status': return_status,
                            'return_message': return_message}
                # If the IP addresses do not match or if the record does not exist,
                # Tell Route 53 to set the DNS record.
                # Then update the record in DynamoDB
                else:
                    return_status = route53_set(
                        'set_record',
                        aws_region,
                        route_53_zone_id,
                        set_hostname,
                        route_53_record_ttl,
                        route_53_record_type,
                        set_ip)
                    # Update DynamoDB with IP and update timestamp
                    ddb_config(set_hostname, route_53_record_type, set_ip, 'write')
                    return_status = 'success'
                    return_message = 'Your hostname record ' + set_hostname +\
                        ' has been set to ' + set_ip
                    return {'return_status': return_status,
                            'return_message': return_message}

        ''' The function that Lambda executes.
            It contains the main script logic, calls 
            and returns the output back to API Gateway'''
        def lambda_handler(event, context):
            # Set event data from the API Gateway to variables.
            execution_mode = event['execution_mode']
            source_ip = event['source_ip']
            query_string = event['query_string']
            internal_ip = event['internal_ip']
            validation_hash = event['validation_hash']
            set_hostname = event['set_hostname']
            # Add a trailing . from the domain name to normalize the record key in DDB
            if not set_hostname.endswith('.'):
              set_hostname = set_hostname + '.'

            # Verify that the execution mode was set correctly.
            execution_modes = ('set', 'get')
            if execution_mode not in execution_modes:
                return_status = 'fail'
                return_message = 'You must pass mode=get or mode=set arguments.'
                return_dict = {'return_status': return_status,
                               'return_message': return_message}

            # For get mode, reflect the client's public IP address and exit.
            if execution_mode == 'get':
                return_status = 'success'
                return_message = source_ip
                return_dict = {'return_status': return_status,
                               'return_message': return_message}

            # Proceed with set mode to create or update the DNS record.
            else:
            # Check if internal_ip was set
                if internal_ip == "":
                    set_ip = source_ip
                else:
                    set_ip = internal_ip
                # Determine ipv4/ipv6, assumes AAAA if ipv4 regext does not match.
                if not re.match(r'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}', set_ip):
                  record_type = 'AAAA'
                else:
                  record_type = 'A'
                #route_53_record_type = record_type
                return_dict = run_set_mode(set_hostname, record_type, validation_hash, source_ip, set_ip)

            # This Lambda function always exits as a success
            # and passes success or failure information in the json message.
            return return_dict

  ddnsCloudFrontAliased:
    Type: 'AWS::CloudFront::Distribution'
    #Condition: debugCond
    Condition: cloudfrontAlias
    DependsOn: runSetup
    Properties:
      DistributionConfig:
        PriceClass: PriceClass_100
        Origins:
          - DomainName: !Sub '${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com'
            Id: !Ref ddnsApi
            # OriginCustomHeaders:
            #   - OriginCustomHeader
            OriginPath: "/prod"
            CustomOriginConfig:
              #HTTPPort: '80'
              HTTPSPort: '443'
              OriginProtocolPolicy: https-only
              OriginSSLProtocols: 
                - TLSv1.2
                - TLSv1.1
        Enabled: True
        Aliases: 
          - !Sub '${apiCname}.${route53ZoneName}'
        ViewerCertificate: 
          #AcmCertificateArn: !If [!Equals !Ref acmCertificateARN, ''], [!GetAtt runSetup.acmCertificateARN], [!Ref acmCertificateARN]
          AcmCertificateArn: !If [useExistingCert, !Ref acmCertificateARN, !GetAtt runSetup.acmCertificateARN]
          SslSupportMethod: 'sni-only' 
        DefaultCacheBehavior:
          TargetOriginId: !Ref ddnsApi
          ForwardedValues:
            QueryString: 'true'
          ViewerProtocolPolicy: redirect-to-https
          Compress: False
          DefaultTTL: 0
          MaxTTL: 0
          MinTTL: 0
        Comment: !Ref AWS::StackName
        HttpVersion: http2
        IPV6Enabled: True
      Tags:
        - Key: created-by
          Value: !Ref AWS::StackName

  ddnsCloudFront:
    Type: 'AWS::CloudFront::Distribution'
    #Condition: debugCond
    Condition: cloudfrontNoAlias
    Properties:
      DistributionConfig:
        PriceClass: PriceClass_100
        Origins:
          - DomainName: !Sub '${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com'
            Id: !Ref ddnsApi
            # OriginCustomHeaders:
            #   - OriginCustomHeader
            OriginPath: "/prod"
            CustomOriginConfig:
              #HTTPPort: '80'
              HTTPSPort: '443'
              OriginProtocolPolicy: https-only
              OriginSSLProtocols: 
                - TLSv1.2
                - TLSv1.1
        Enabled: True
        DefaultCacheBehavior:
          TargetOriginId: !Ref ddnsApi
          ForwardedValues:
            QueryString: 'true'
          ViewerProtocolPolicy: redirect-to-https
          Compress: False
          DefaultTTL: 0
          MaxTTL: 0
          MinTTL: 0
        Comment: !Ref AWS::StackName
        HttpVersion: http2
        IPV6Enabled: True
      Tags:
        - Key: created-by
          Value: !Ref AWS::StackName
  ## Un-implemented as CloudFormation does not support dns validation for ACM (3/2018)
  # ddnsAcm:
  #   Type: AWS::CertificateManager::Certificate
  #   Properties:
  #     DomainName: !Sub '${apiCname}.${route53ZoneName}'
  #     DomainValidationOptions:
  #       - DomainName: !Sub '${apiCname}.${route53ZoneName}'
  #         ValidationDomain: !Ref route53ZoneName

  ddnsApi:
    Type: "AWS::ApiGateway::RestApi"
    Properties:
      Name: !Sub ${AWS::StackName}-api
      Description: String
      EndpointConfiguration: 
        Types: 
          - REGIONAL
      Body:
        swagger: 2.0
        info:
          title:
            Ref: AWS::StackName
        basePath: "/prod"
        schemes:
        - "https"
        paths:
          "/":
            get:
              consumes:
              - "application/json"
              produces:
              - "application/json"
              responses:
                "200":
                  description: "200 response"
                  schema:
                    $ref: "#/definitions/Empty"
              x-amazon-apigateway-integration:
                responses:
                  default:
                    statusCode: "200"
                uri: 
                  Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${lambdaDdnsFunction.Arn}/invocations
                passthroughBehavior: "when_no_match"
                httpMethod: "POST"
                requestTemplates:
                  application/json: "{\n    \"execution_mode\" : \"$input.params('mode')\"\
                    ,\n    \"source_ip\" : \"$context.identity.sourceIp\",\n    \"internal_ip\"\
                    \ : \"$input.params('internalIp')\",\n    \"query_string\" : \"$input.params().querystring\"\
                    ,\n    \"set_hostname\" : \"$input.params('hostname')\",\n    \"validation_hash\"\
                    \ : \"$input.params('hash')\"\n,\n    \"ipv6_address\"\
                    \ : \"$input.params('ipv6_address')\"\n}"
                type: "aws"
        definitions:
          Empty:
            type: "object"
            title: "Empty Schema"

  ddnsApiProdStage:
    Type: "AWS::ApiGateway::Stage"
    Properties:
      DeploymentId: !Ref ddnsApiDeployment
      MethodSettings:
        - HttpMethod: '*'
          ResourcePath: /*
      RestApiId: !Ref ddnsApi
      StageName: LATEST

  ddnsApiDeployment:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref 'ddnsApi'
      StageName: prod

  lambdaDdnsRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-lambda-ddns
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-lambda-ddns
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Resource: "*"
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
              #- Resource: !Sub arn:aws:route53:::hostedzone/${route53Zone}
              - Resource: !If [useExistingZone, !Sub 'arn:aws:route53:::hostedzone/${route53ZoneId}', !Sub 'arn:aws:route53:::hostedzone/${route53newZone}']
                Effect: Allow
                Action:
                  - route53:ListResourceRecordSets
                  - route53:ChangeResourceRecordSets
              - Resource: "arn:aws:route53:::change/*"
                Effect: Allow
                Action:
                  - route53:GetChange
              - Resource: !Sub arn:aws:s3:::${ddnsConfigBucket}/*
                Effect: Allow
                Action:
                  - s3:Get*
                  - s3:List*
                  - s3:PutObject
              - Resource: !GetAtt ddnsConfigTable.Arn
                Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:BatchGetItem  
                  - dynamodb:PutItem 
                  - dynamodb:UpdateItem  
                  - dynamodb:Scan   
              - Resource: "*"
                Effect: Allow
                Action:
                  - acm:ListCertificates
                  - acm:DescribeCertificate
                  - acm:RequestCertificate

  apiGatewayRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-apigateway
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - apigateway.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-apigateway
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Resource: !GetAtt lambdaDdnsFunction.Arn
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
  lambdaInvocationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ddnsApi}/*/GET/'
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      FunctionName: !GetAtt lambdaDdnsFunction.Arn

Outputs:
  apiUrl:
    Value:
      !If [enableCloudFront, !If [cloudfrontAlias, !Sub '${apiCname}.${route53ZoneName}', !GetAtt ddnsCloudFront.DomainName],  !Sub '${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com/prod']
    Description:
      DDNS API URL
  originURL:
    Value:
      !Sub '${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com/prod'
    Description:
      API Gateway url, use for cname if manually implementing an API custom alias.
  route53ZoneName:
    Value:
      !Ref route53ZoneName
  route53ZoneID: 
    Value:
      !If [useExistingZone, !Ref route53ZoneId, !Ref route53newZone]
  DNSZoneNameServers: 
    Value:
      !If [createNewZone, !Join [ " ", !GetAtt route53newZone.NameServers ] , '' ]
    Description:
      Name Servers for DNS Zone if created by stack.  Use for delegation of subdomain.
  acmCertArn:
    Value:
        !If [cloudfrontAlias, !GetAtt runSetup.acmCertificateARN, '']
## Helps debug script conditional logic.    
#  ConditionUseExistingZone:
#    Value:
#      !If [useExistingZone, 'true', 'false']
#  ConditionCreateNewZone:
#    Value:
#        !If [createNewZone, 'true', 'false']
#  ConditionEnableIpv6:
#    Value:
#        !If [enableIpv6, 'true', 'false']
#  ConditionCloudfrontAlias:
#    Value:
#        !If [cloudfrontAlias, 'true', 'false']
#  ConditionCloudfrontNoAlias:
#    Value:
#        !If [cloudfrontNoAlias, 'true', 'false']
#  ConditionUseExistingZone:
#    Value:
#        !If [useExistingZone, 'true', 'false']
#  ConditionEnableCloudFront:
#    Value:
#        !If [enableCloudFront, 'true', 'false']

  templateVersion:
     Value: 
      !Ref templateVersion