AWSTemplateFormatVersion: '2010-09-09'
Description: Serverless dynamic DNS & device discovery service for ipv4 & ipv6
## Resource names are keyed off the Stack name, so multiple copies of the stack can be run in the same Account & Region

## Working version that lacks conditionals and api cname

Parameters:
  route53ZoneName:
    Type: String
    Default: 'ddns.greathou.se'
    Description: Route53 Zone

  defaultTtl:
    Type: String
    Default: 60
    Description: Default DNS record TTL, can be overridden for individual records in DynamoDB config.

  templateVersion:
    Type: String
    Default: 1
    Description: "For debugging, increment this parameter to force CFN to re-run the template"
    ## Uses a matching output to force the update
      
Resources:
  route53Zone: 
    Type: "AWS::Route53::HostedZone"
    Properties: 
      HostedZoneConfig: 
        Comment: !Sub Zone for ${AWS::StackName}
      Name: !Ref route53ZoneName
      HostedZoneTags: 
        - 
          Key: "CreatedBy"
          Value: !Ref AWS::StackName

  ddnsConfigTable: 
    Type: "AWS::DynamoDB::Table"
    Properties: 
      TableName: !Sub ${AWS::StackName}-config
      AttributeDefinitions: 
        - 
          AttributeName: "hostname"
          AttributeType: "S"
        - 
          AttributeName: "record_type"
          AttributeType: "S"
      KeySchema: 
        - 
          AttributeName: "hostname"
          KeyType: "HASH"
        - 
          AttributeName: "record_type"
          KeyType: "RANGE"
      ProvisionedThroughput: 
        ReadCapacityUnits: "5"
        WriteCapacityUnits: "5"

  ddnsConfigBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Join [ "-", [ !Ref "AWS::StackName", !Ref "AWS::Region", !Ref "AWS::AccountId"] ]
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
        - Id: Delete_Old_Versions
          NoncurrentVersionExpirationInDays: 90
          Status: Enabled

  lambdaDdnsFunction:
    Type: AWS::Lambda::Function
    DependsOn: sourceToS3
    Properties:
      FunctionName: !Sub ${AWS::StackName}-lambda-ddns
      Handler: index.lambda_handler
      Runtime: python2.7
      MemorySize: 512
      Timeout: 30
      Role: !GetAtt lambdaDdnsRole.Arn
      Environment:
        Variables:
          ddns_config_table: !Ref ddnsConfigTable
          route_53_zone_id: !Ref route53Zone
          route_53_zone_name: !Ref route53ZoneName
          default_ttl: !Ref defaultTtl
      Code:
        S3Bucket: !Ref ddnsConfigBucket
        S3Key: ddns_lambda.zip
        S3ObjectVersion: !GetAtt sourceToS3.S3ObjectVersion

  setupLambda:
    Type: AWS::Lambda::Function
    DependsOn: ddnsConfigTable
    Properties:
      FunctionName: !Sub ${AWS::StackName}-setup
      Handler: index.lambda_handler
      Runtime: python2.7
      Timeout: 30
      Role: !GetAtt lambdaDdnsRole.Arn
      Environment:
        Variables:
          ddns_config_table: !Ref ddnsConfigTable
          route_53_zone_id: !Ref route53Zone
          route_53_zone_name: !Ref route53ZoneName
          route_53_region: !Ref AWS::Region
      Code:
        ZipFile: |
          #force function to run by changing this: 1
          from __future__ import print_function
          import boto3
          import datetime  
          import random
          import os   
          import uuid
          import httplib
          import urlparse
          import json

          print('Loading function')
          from botocore.client import Config
          from botocore.exceptions import ClientError

          # Import Lambda environment variables
          ddns_config_table = os.environ['ddns_config_table']
          route_53_zone_id = os.environ['route_53_zone_id']
          route_53_zone_name = os.environ['route_53_zone_name']
          route_53_region = os.environ['route_53_region']

          def send_response(request, response, status=None, reason=None):
              """ Send our response to the pre-signed URL supplied by CloudFormation"""
              if status is not None:
                  response['Status'] = status
              if reason is not None:
                  response['Reason'] = reason
              if 'ResponseURL' in request and request['ResponseURL']:
                  url = urlparse.urlparse(request['ResponseURL'])
                  body = json.dumps(response)
                  https = httplib.HTTPSConnection(url.hostname)
                  https.request('PUT', url.path+'?'+url.query, body)
              return response

          def lambda_handler(event, context):
              response = {
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Status': 'SUCCESS'
              }
              # PhysicalResourceId is meaningless here, but CloudFormation requires it
              if 'PhysicalResourceId' in event:
                  response['PhysicalResourceId'] = event['PhysicalResourceId']
              else:
                  response['PhysicalResourceId'] = str(uuid.uuid4())

              # There is nothing to do for a delete request
              if event['RequestType'] == 'Delete':
                  return send_response(event, response)

              try:
                # Define the DDB client.
                dynamodb = boto3.resource('dynamodb')
                dynamodb_table = dynamodb.Table(ddns_config_table)
                dynamodb_table.put_item(
                  Item={
                  'hostname': 'example-reserved-record.' + route_53_zone_name, 
                  'record_type': 'A',
                  'aws_region': route_53_region,
                  'zone_id': route_53_zone_id, 
                  'ttl': 60,
                  'shared_secret': str(random.randint(100000, 999999)), 
                  'lock_record': False, 
                  'ip_address': '1.1.1.1', 
                  'mac_address': 'FF:00:AA:33:EE:CC', 
                  'last_checked': str(datetime.datetime.now()), 
                  'last_updated': str(datetime.datetime.now())
                  }
                )
                dynamodb_table.put_item(
                  Item={
                  'hostname': 'example-reserved-record.' + route_53_zone_name, 
                  'record_type': 'AAAA',
                  'aws_region': route_53_region,
                  'zone_id': route_53_zone_id, 
                  'ttl': 60,
                  'shared_secret': str(random.randint(100000, 999999)), 
                  'lock_record': False, 
                  'ip_address': '2001:564:6045:96:d66:c133:2ab3:7b01', 
                  'mac_address': 'FF:00:AA:33:EE:CC', 
                  'last_checked': str(datetime.datetime.now()), 
                  'last_updated': str(datetime.datetime.now())
                  }
                )
                response['Reason'] = 'Event Succeeded'
              except ClientError as e:
                print("Unexpected error: %s" % e)
                response['Reason'] = 'Event Failed - See CloudWatch logs for the Lamba function backing the custom resource for details'
                ## Un-comment the line blow to send a true failure to CFN
                ## will cause a stack rollback on failure and can leave the stack in a state that requires deletion.
                #response['Status'] = 'FAILED'
              return send_response(event, response)

  runSetup:
    Type: Custom::setupLambda
    DependsOn: setupLambda
    Properties:
      ServiceToken: !GetAtt setupLambda.Arn
      Region: !Ref AWS::Region
      stackName: !Ref AWS::StackName
      forceUpdate: !Ref templateVersion

  sourceToS3Lambda:
    Type: AWS::Lambda::Function
    DependsOn: ddnsConfigBucket
    Properties:
      FunctionName: !Sub ${AWS::StackName}-source-to-s3
      Handler: index.lambda_handler
      Runtime: python2.7
      Timeout: 30
      Role: !GetAtt lambdaDdnsRole.Arn
      Code:
        ZipFile: |
          from __future__ import print_function
          import boto3
          import os
          import zipfile
          import httplib
          import uuid
          import urlparse
          import json
           
          print('Loading function')
          from botocore.client import Config
          s3 = boto3.client('s3')
          
          def send_response(request, response, status=None, reason=None):
              """ Send our response to the pre-signed URL supplied by CloudFormation"""
              if status is not None:
                  response['Status'] = status
              if reason is not None:
                  response['Reason'] = reason
              if 'ResponseURL' in request and request['ResponseURL']:
                  url = urlparse.urlparse(request['ResponseURL'])
                  body = json.dumps(response)
                  https = httplib.HTTPSConnection(url.hostname)
                  https.request('PUT', url.path+'?'+url.query, body)
              return response
          
          def lambda_handler(event, context):
              response = {
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Status': 'SUCCESS'
              }
              # PhysicalResourceId is meaningless here, but CloudFormation requires it
              if 'PhysicalResourceId' in event:
                  response['PhysicalResourceId'] = event['PhysicalResourceId']
              else:
                  response['PhysicalResourceId'] = str(uuid.uuid4())
          
              # There is nothing to do for a delete request
              if event['RequestType'] == 'Delete':
                  return send_response(event, response)

              ## Get the S3 Bucket passed in from CFN
              s3TargetBucket=event['ResourceProperties']['s3TargetBucket']
              ## Get the file contents to put in S3 from CFN
              lambda_body=event['ResourceProperties']['lambda_body']

              ## Write the body variable to a file
              ## and change perms to add exec
              lambda_file = open('/tmp/index.py', 'w')
              os.chmod('/tmp/index.py', 0777)
              lambda_file.write(lambda_body)
              lambda_file.close()

              ## Build the zip archive
              zip_archive = zipfile.ZipFile('/tmp/ddns_lambda.zip', 'w')
              zip_archive.write('/tmp/index.py', 'index.py')
              zip_archive.close()
              zip_file = open('/tmp/ddns_lambda.zip', 'r')
          
              ## Put the archive in S3
              try:
                  s3_response = s3.put_object(
                  Body= zip_file.read(),
                  Bucket= s3TargetBucket,
                  Key= "ddns_lambda.zip",
                  )
                  response['Data'] = {
                      's3Success': 'true',
                      'S3ObjectVersion': s3_response['VersionId']
                  }
                  response['Reason'] = 'ddns_lambda.zip added to S3'
                  #response['S3ObjectVersion'] = s3_response['VersionId']
                  #response['Data']['S3ObjectVersion']
                  print(str(s3_response['VersionId']))

              except Exception as E:
                response['Reason'] = 'Event Failed - See CloudWatch logs for the Lamba function backing the custom resource for details'
                ## Un-comment the line blow to send a true failure to CFN
                ## will cause a stack rollback on failure and can leave the stack in a state that requires deletion.
                #response['Status'] = 'FAILED'
              # Log it!
              print(str(s3_response))
              print('Response Text: ' + str(response))
              return send_response(event, response)

  ## Invoke the sourceToS3Lambda function and send the body text of files to put in S3
  ## Lambda-backed custom resources provisioned inline in CFN via the Zipfile method have a 4096 byte limit.  
  ## We pass the DDNS Lambda function code to sourceToS3Lambda which zips the code into S3 to avoid exceeding that limit.
  sourceToS3:
    Type: Custom::sourceToS3Lambda
    DependsOn: sourceToS3Lambda
    Properties:
      ServiceToken: !GetAtt sourceToS3Lambda.Arn
      Region: !Ref "AWS::Region"
      stackName: !Ref AWS::StackName
      s3TargetBucket: !Ref ddnsConfigBucket
      lambda_body: |
        #force function to run by changing this: 1
        # version works with DDB
        # Dynamic DNS via AWS API Gateway, Lambda & Route 53
        # Script variables use lower_case_
        from __future__ import print_function

        import json
        import re
        import hashlib
        import boto3
        import datetime
        import os

        # Import Lambda environment variables
        ddns_config_table = os.environ['ddns_config_table']
        route_53_zone_id_imported = os.environ['route_53_zone_id']
        route_53_zone_name_imported = os.environ['route_53_zone_name']
        default_ttl = int(os.environ['default_ttl'])

        ''' This function pulls the config entry from DynamoDB 
            It is called by the run_set_mode function.'''
        def ddb_config(route_53_record_name, route_53_record_type, set_ip, read_write):
            # Define the DDB client.
            #print(route_53_record_name + route_53_record_type)
            dynamodb = boto3.resource('dynamodb')
            dynamodb_table = dynamodb.Table(ddns_config_table)
            if read_write == 'read':
              try:
                config_record = dynamodb_table.get_item(
                    Key={
                    'hostname': route_53_record_name,
                    'record_type': route_53_record_type
                    })
                dynamodb_table.update_item(
                    Key={
                    'hostname': route_53_record_name,
                    'record_type': route_53_record_type
                    },
                    UpdateExpression='SET last_checked = :now_time',
                    ConditionExpression='attribute_exists(hostname) AND attribute_exists(record_type)',
                    ExpressionAttributeValues={
                        ':now_time': str(datetime.datetime.now())
                    }
                    #ConditionExpression='lock_record = :locked', ':locked': {'BOOL': False }
                )
              except:
                return_status = 'fail'
                return_message = 'ddb_config There was an issue finding '\
                    'or reading the DyanmoDB config item for '+set_hostname+': '+record_type
                return {'return_status': return_status,
                        'return_message': return_message}

              #print(str(config_record))
              return config_record
            elif read_write == 'write':
                dynamodb_table.update_item(
                    Key={
                    'hostname': route_53_record_name,
                    'record_type': route_53_record_type                      },
                    UpdateExpression='SET last_updated = :now_time , ip_address = :ip ',
                    ExpressionAttributeValues={
                        ':now_time': str(datetime.datetime.now()),
                        ':ip': set_ip
                    },
                    ConditionExpression='attribute_exists(hostname) AND attribute_exists(record_type)'
                )
                return

        ''' This function defines the interaction with Route 53.
            It is called by the run_set_mode function.
            @param execution_mode defines whether to set or get a DNS record
            @param aws_region defines region to call
            @param route_53_zone_id defines the id for the DNS zone
            @param route_53_record_name defines the record, ie www.acme.com.
            @param route_53_record_ttl defines defines the DNS record TTL
            @param route_53_record_type defines record type, should always be 'a'
            @param public_ip defines the current public ip of the client
            '''
        def route53_client(execution_mode, aws_region, route_53_zone_id,
                           route_53_record_name, route_53_record_ttl,
                           route_53_record_type, public_ip):
            # Define the Route 53 client
            route53_client = boto3.client(
                'route53',
                region_name=aws_region
            )

            # Query Route 53 for the current DNS record.
            if execution_mode == 'get_record':
                current_route53_record_set = route53_client.list_resource_record_sets(
                    HostedZoneId=route_53_zone_id,
                    StartRecordName=route_53_record_name,
                    StartRecordType=route_53_record_type,
                    MaxItems='2'
                )
                # boto3 returns a dictionary with a nested list of dictionaries
                # see: http://boto3.readthedocs.org/en/latest/reference/services/
                # route53.html#Route53.Client.list_resource_record_sets
                # Parse the dict to find the current IP for the hostname, if it exists.
                # If it doesn't exist, the function returns False.
                for eachRecord in current_route53_record_set['ResourceRecordSets']:
                    if eachRecord['Name'] == route_53_record_name:
                        # If there's a single record, pass it along.
                        if len(eachRecord['ResourceRecords']) == 1:
                            for eachSubRecord in eachRecord['ResourceRecords']:
                                currentroute53_ip = eachSubRecord['Value']
                                return_status = 'success'
                                return_message = currentroute53_ip
                                return {'return_status': return_status,
                                        'return_message': return_message}
                        # Error out if there is more than one value for the record set.
                        elif len(eachRecord['ResourceRecords']) > 1:
                            return_status = 'fail'
                            return_message = 'You should only have a single value for'\
                            ' your dynamic record.  You currently have more than one.'
                            return {'return_status': return_status,
                                    'return_message': return_message}

            # Set the DNS record to the current IP.
            if execution_mode == 'set_record':
                change_route53_record_set = route53_client.change_resource_record_sets(
                    HostedZoneId=route_53_zone_id,
                    ChangeBatch={
                        'Changes': [
                            {
                                'Action': 'UPSERT',
                                'ResourceRecordSet': {
                                    'Name': route_53_record_name,
                                    'Type': route_53_record_type,
                                    'TTL': route_53_record_ttl,
                                    'ResourceRecords': [
                                        {
                                            'Value': public_ip
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                )
                return 1

        ''' This function calls route53_client to see if the current Route 53 
            DNS record matches the client's current IP.
            If not it calls route53_client to set the DNS record to the current IP.
            It is called by the main lambda_handler function.
            '''
        def run_set_mode(set_hostname, record_type, validation_hash, source_ip, set_ip ):
            # Try to read the config, and error if you can't.
            try:
                record_config_set = ddb_config(set_hostname, record_type, '', 'read')
            except:
                return_status = 'fail'
                return_message = 'There was an issue finding '\
                    'or reading the DyanmoDB config item for '+set_hostname+': '+record_type
                return {'return_status': return_status,
                        'return_message': return_message}
            # Check to see if the record is locked
            lock_record = record_config_set['Item']['lock_record']
            if lock_record:
                return_status = 'fail'
                return_message = 'The record for ' + set_hostname + ' is locked, update denied.'
                return {'return_status': return_status,
                        'return_message': return_message}

            # # Check if internal_ip was set
            # if internal_ip == "":
            #     set_ip = source_ip
            # else:
            #     set_ip = internal_ip
            # # Determine ipv4/ipv6, assumes AAAA if ipv4 regex does not match.
            # if not re.match(r'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}', set_ip):
            #   record_type = 'AAAA'
            # else:
            #   record_type = 'A'
            # route_53_record_type = record_type

            aws_region = record_config_set['Item']['aws_region']
            # the Route 53 Zone you created for the script
            try:
              route_53_zone_id = record_config_set['Item']['zone_id']
            except: 
              route_53_zone_id = route_53_zone_id_imported

            # record TTL (Time To Live) in seconds tells DNS servers how long to cache
            # the record.
            try:
              route_53_record_ttl = int(record_config_set['Item']['ttl'])
            except: 
              route_53_record_ttl = default_ttl
              
            route_53_record_type = record_config_set['Item']['record_type']
            shared_secret = record_config_set['Item']['shared_secret']

            # Validate that the client passed a sha256 hash
            # regex checks for a 64 character hex string.
            if not re.match(r'[0-9a-fA-F]{64}', validation_hash):
                return_status = 'fail'
                return_message = 'You must pass a valid sha256 hash in the '\
                    'hash= argument.'
                return {'return_status': return_status,
                        'return_message': return_message}

            # Calculate the validation hash.
            calculated_hash = hashlib.sha256(
                source_ip + set_hostname + shared_secret).hexdigest()
            # Compare the validation_hash from the client to the
            # calculated_hash.
            # If they don't match, error out.
            if not calculated_hash == validation_hash:
                return_status = 'fail'
                return_message = 'Validation hashes do not match.'
                return {'return_status': return_status,
                        'return_message': return_message}
            # If they do match, get the current ip address associated with
            # the hostname DNS record from Route 53.
            else:
                route53_get_response = route53_client(
                    'get_record',
                    aws_region,
                    route_53_zone_id,
                    set_hostname,
                    route_53_record_ttl,
                    route_53_record_type,
                    '')
                # If no records were found, route53_client returns null.
                # Set route53_ip and stop evaluating the null response.
                if not route53_get_response:
                    route53_ip = '0'
                # Pass the fail message up to the main function.
                elif route53_get_response['return_status'] == 'fail':
                    return_status = route53_get_response['return_status']
                    return_message = route53_get_response['return_message']
                    return {'return_status': return_status,
                            'return_message': return_message}
                else:
                    route53_ip = route53_get_response['return_message']
                # If the client's current IP matches the current DNS record
                # in Route 53 there is nothing left to do.
                if route53_ip == set_ip:
                    return_status = 'success'
                    return_message = 'Your IP address matches '\
                        'the current Route53 DNS record.'
                    return {'return_status': return_status,
                            'return_message': return_message}
                # If the IP addresses do not match or if the record does not exist,
                # Tell Route 53 to set the DNS record.
                # Then update the record in DynamoDB
                else:
                    return_status = route53_client(
                        'set_record',
                        aws_region,
                        route_53_zone_id,
                        set_hostname,
                        route_53_record_ttl,
                        route_53_record_type,
                        set_ip)
                    # Update DynamoDB with IP and update timestamp
                    ddb_config(set_hostname, route_53_record_type, set_ip, 'write')
                    return_status = 'success'
                    return_message = 'Your hostname record ' + set_hostname +\
                        ' has been set to ' + set_ip
                    return {'return_status': return_status,
                            'return_message': return_message}

        ''' The function that Lambda executes.
            It contains the main script logic, calls 
            and returns the output back to API Gateway'''
        def lambda_handler(event, context):
            # Set event data from the API Gateway to variables.
            execution_mode = event['execution_mode']
            source_ip = event['source_ip']
            query_string = event['query_string']
            internal_ip = event['internal_ip']
            validation_hash = event['validation_hash']
            set_hostname = event['set_hostname']
            # Add a trailing . from the domain name to normalize the record key in DDB
            if not set_hostname.endswith('.'):
              set_hostname = set_hostname + '.'

            # Verify that the execution mode was set correctly.
            execution_modes = ('set', 'get')
            if execution_mode not in execution_modes:
                return_status = 'fail'
                return_message = 'You must pass mode=get or mode=set arguments.'
                return_dict = {'return_status': return_status,
                               'return_message': return_message}

            # For get mode, reflect the client's public IP address and exit.
            if execution_mode == 'get':
                return_status = 'success'
                return_message = source_ip
                return_dict = {'return_status': return_status,
                               'return_message': return_message}

            # Proceed with set mode to create or update the DNS record.
            else:
            # Check if internal_ip was set
                if internal_ip == "":
                    set_ip = source_ip
                else:
                    set_ip = internal_ip
                # Determine ipv4/ipv6, assumes AAAA if ipv4 regext does not match.
                if not re.match(r'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}', set_ip):
                  record_type = 'AAAA'
                else:
                  record_type = 'A'
                #route_53_record_type = record_type
                return_dict = run_set_mode(set_hostname, record_type, validation_hash, source_ip, set_ip)

            # This Lambda function always exits as a success
            # and passes success or failure information in the json message.
            return return_dict


  ddnsCloudFront:
    Type: 'AWS::CloudFront::Distribution'
    Properties:
      DistributionConfig:
        PriceClass: PriceClass_100
        Origins:
          - DomainName: !Sub '${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com'
            Id: !Ref ddnsApi
            # OriginCustomHeaders:
            #   - OriginCustomHeader
            OriginPath: "/prod"
            CustomOriginConfig:
              #HTTPPort: '80'
              HTTPSPort: '443'
              OriginProtocolPolicy: https-only
              OriginSSLProtocols: 
                - TLSv1.2
                - TLSv1.1
        Enabled: True
        #Aliases:
        #  - !Sub '${apiCname}.${route53ZoneName}'
        # ViewerCertificate:
        #   AcmCertificateArn: !Ref 'ddnsAcm'
        #   SslSupportMethod: sni-only
        DefaultCacheBehavior:
          TargetOriginId: !Ref ddnsApi
          ForwardedValues:
            QueryString: 'true'
          ViewerProtocolPolicy: redirect-to-https
          Compress: False
          DefaultTTL: 0
          MaxTTL: 0
          MinTTL: 0
        Comment: !Ref AWS::StackName
        HttpVersion: http2
        IPV6Enabled: True
      Tags:
        - Key: created-by
          Value: !Ref AWS::StackName

  # ddnsAcm:
  #   Type: AWS::CertificateManager::Certificate
  #   Properties:
  #     DomainName: !Sub '${apiCname}.${route53ZoneName}'
  #     DomainValidationOptions:
  #       - DomainName: !Sub '${apiCname}.${route53ZoneName}'
  #         ValidationDomain: !Ref route53ZoneName

  ddnsApi:
    Type: "AWS::ApiGateway::RestApi"
    Properties:
      Name: !Sub ${AWS::StackName}-api
      Description: String
      EndpointConfiguration: 
        Types: 
          - REGIONAL
      Body:
        swagger: 2.0
        info:
          title:
            Ref: AWS::StackName
        basePath: "/prod"
        schemes:
        - "https"
        paths:
          "/":
            get:
              consumes:
              - "application/json"
              produces:
              - "application/json"
              responses:
                "200":
                  description: "200 response"
                  schema:
                    $ref: "#/definitions/Empty"
              x-amazon-apigateway-integration:
                responses:
                  default:
                    statusCode: "200"
                uri: 
                  Fn::Sub: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${lambdaDdnsFunction.Arn}/invocations
                passthroughBehavior: "when_no_match"
                httpMethod: "POST"
                requestTemplates:
                  application/json: "{\n    \"execution_mode\" : \"$input.params('mode')\"\
                    ,\n    \"source_ip\" : \"$context.identity.sourceIp\",\n    \"internal_ip\"\
                    \ : \"$input.params('internalIp')\",\n    \"query_string\" : \"$input.params().querystring\"\
                    ,\n    \"set_hostname\" : \"$input.params('hostname')\",\n    \"validation_hash\"\
                    \ : \"$input.params('hash')\"\n,\n    \"ipv6_address\"\
                    \ : \"$input.params('ipv6_address')\"\n}"
                type: "aws"
        definitions:
          Empty:
            type: "object"
            title: "Empty Schema"

  ddnsApiProdStage:
    Type: "AWS::ApiGateway::Stage"
    Properties:
      DeploymentId: !Ref ddnsApiDeployment
      MethodSettings:
        - HttpMethod: '*'
          ResourcePath: /*
      RestApiId: !Ref ddnsApi
      StageName: LATEST

  ddnsApiDeployment:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref 'ddnsApi'
      StageName: prod

  lambdaDdnsRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-lambda-ddns
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-lambda-ddns
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Resource: "*"
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
              - Resource: !Sub arn:aws:route53:::hostedzone/${route53Zone}
                Effect: Allow
                Action:
                  - route53:ListResourceRecordSets
                  - route53:ChangeResourceRecordSets
              - Resource: "arn:aws:route53:::change/*"
                Effect: Allow
                Action:
                  - route53:GetChange
              - Resource: !Sub arn:aws:s3:::${ddnsConfigBucket}/*
                Effect: Allow
                Action:
                  - s3:Get*
                  - s3:List*
                  - s3:PutObject
              - Resource: !GetAtt ddnsConfigTable.Arn
                Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:BatchGetItem  
                  - dynamodb:PutItem 
                  - dynamodb:UpdateItem  
                  - dynamodb:Scan   

  apiGatewayRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${AWS::StackName}-apigateway
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - apigateway.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-apigateway
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Resource: !GetAtt lambdaDdnsFunction.Arn
                Effect: Allow
                Action:
                  - lambda:InvokeFunction
  lambdaInvocationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ddnsApi}/*/GET/'
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      FunctionName: !GetAtt lambdaDdnsFunction.Arn

Outputs:
  APIURL:
    Value:
      !GetAtt ddnsCloudFront.DomainName
    Description:
      CloudFront API URL
  OriginURL:
    Value:
      !Sub 'https://${ddnsApi}.execute-api.${AWS::Region}.amazonaws.com/prod'
    Description:
      Origin api url for API Gateway
  DNSZoneName:
    Value:
      !Ref route53ZoneName
  # APICNAME:
  #   Value:
  #     !Sub 'https://${apiCname}.${route53ZoneName}'
    Description:
      CNAME for your api, auto-created in your zone, points to CloudFront distribution.
  APIARN:
    Value:
      !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ddnsApi}/*/GET/'
  # APIRootResourceId:
  #   Value:
  #     !GetAtt ddnsApi.RootResourceId
  DynamoDBArn:
    Value:
      !GetAtt ddnsConfigTable.Arn
  DNSZoneID: 
    Value:
      !Ref route53Zone
  # LambdaS3ObjectVersion:
  #   Value:
  #     !GetAtt sourceToS3.S3ObjectVersion
  #   Description:
  #     Object version of Lambda package zip in s3.
  DNSZoneNameServers: 
    Value:
      !Join [ " ", !GetAtt route53Zone.NameServers ] 
    Description:
      Name Servers for DNS Zone.  Use for delegation of subdomain.
  templateVersion:
     Value: 
      !Ref templateVersion